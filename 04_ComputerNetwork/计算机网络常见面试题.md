- [1. 应用层](#1-应用层)
- [2. 传输层](#2-传输层)
- [3. 网络层](#3-网络层)
- [4. 链路层](#4-链路层)

# 1. 应用层

1. 浏览器输入一个网址后发生了什么？
   - DNS解析：获取网址对应的IP地址：浏览器缓存、路由器缓存、本地DNS服务器缓存、根DNS服务器（顶级域DNS服务器、权威DNS服务器）；
   - TCP连接：根据解析得到IP地址和相关端口号在服务器和客户端之间建立TCP连接（三次握手）；
   - 浏览器发送HTTP请求报文；
   - 服务器处理HTTP请求：生成HTTP响应报文，并发送给浏览器；
   - 浏览器根据接收到的HTTP响应报文渲染页面；
   - 关闭TCP连接。

# 2. 传输层

1. TCP的三次握手
   - 客户端首先发送连接请求报文，该报文段中不包含应用层数据，其中标志位：`SYN=1`，初始序列号`seq`设为随机值`x`，此时客户端处于`SYN_SENT`状态；
   - 服务器收到客户端的`SYN`请求报文后，为该TCP连接分配缓存和变量，并客户端发送`SYN=1, ACK=1, seq=y, ack=x+1`允许连接报文段，此时服务器处于`SYN_RCVD`的状态；
   - 客户端收到允许连接报文后，为该TCP连接分配缓存和变量，并向服务器发送`SYN=0, ACK=1, seq=x+1, ack=y+1`的确认报文段，该报文段负载中可以携带应用层数据，此时客户端处于`ESTABLISHED`状态。
   - 服务器收到`ACK`报文段之后，代表已完成连接建立，此时服务器也处于`ESTABLISHED`状态。

2. 为什么需要三次握手，两次不行吗？
   - 三次握手：确保通信双方的发送能力和接收能力正常，确保双方同步初始序列号；
   - 两次握手：服务器无法确定客户端的接收能力是否正常，无法可靠的同步双方序列号；
   - 四次握手：三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数。

3. ISN(Initial Sequence Number)是固定的吗？
   - 不是，初始序列号是随机的；
   - 防止在网络中被延迟的分组在以后又被传送，而导致某个连接的一方对它做错误的解释；
   - 如果初始序列号是固定的，攻击者很容易猜出后续的确认号，因此初始序列号是动态生成的。

4. 三次握手过程中可以携带数据吗？
   - 第三次握手的时候可以携带数据的，第一次、第二次握手不可以携带数据；
   - 第一次握手不可以放数据，原因是会让服务器更加容易受到攻击了；
   - 第三次握手时客户端已经处于 ESTABLISHED 状态。对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据。

5. SYN攻击是什么？
   - 服务器端的资源分配是在二次握手时分配的，而客户端的资源是在完成三次握手时分配的，所以服务器容易受到`SYN`洪泛攻击；
   - `SYN`攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server则回复确认包，并等待Client确认，由于源地址不存在，因此Server需要不断重发直至超时，这些伪造的`SYN`包将长时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。

6. 三次握手连接阶段，最后一次ACK包丢失会进入什么样的一个状态？
   - 服务器端：第三次的ACK在网络中丢失，那么服务器端该TCP连接的状态为`SYN_RECV`，并且会根据 TCP的超时重传机制，会等待3秒、6秒、12秒后重新发送`SYN+ACK`包，以便Client重新发送ACK包。如果重发指定次数之后，仍然未收到client的`ACK`应答，那么一段时间后，服务器自动关闭这个连接。
   - 客户端：如果第三次握手中的`ACK`包丢失的情况下，客户端向服务器端发送数据，服务器端将以`RST`包响应，方能感知到Server的错误。

7. 如果已经建立了连接，但是客户端突然出现故障了怎么办？
   - 服务器端会进行超时探测，若超时未收到客户端的响应后，会连续向客户端发送探测报文段，如果此时客户端仍未响应，则服务器将关闭TCP连接；

8. TCP的四次挥手:
   - 客户端向服务器请求释放连接，发送`FIN=1`的报文段给服务器，说明客户端不会继续发送数据给服务器；
   - 服务器接收到客户端发送的`FIN=1`报文段，并回复`ACK`报文段给客户端，同意释放从客户端到服务器的连接；
   - 客户端收到服务器回复的`ACK=1`报文段，此时从客户端到服务器的TCP连接已释放，但服务器到客户端的TCP连接还未释放，客户端还可以接收数据，服务器可以继续发送之前没发完的数据给客户端；
   - 服务器发送完数据后，向客户端发送`FIN=1`报文段，说明服务器发送完了数据，请求释放从服务器到客户端的TCP连接；
   - 客户端收到服务器的`FIN=1`报文段，回复`ACK`报文段给服务器，同意释放从服务器到客户端的连接；
   - 服务器收到客户端的`ACK`后，释放从服务器到客户端的连接。

9. 为什么连接的时候是三次握手，关闭的时候却是四次握手？
    - TCP是全双工模式，客户端通过第一和第二次挥手请求关闭连接后，服务器可能还需要继续传输之前没传完的数据给客户端，所以服务器在第二次挥手时仅回复`ACK`而没有`FIN`。当服务器传输完数据后，再通过第三和第四次挥手关闭连接关闭；
    - TCP建立连接时服务器的ACK和SYN是一起发送的（第二次握手），所以TCP建立连接需要三次，而释放连接则需要四次。

10. 为什么TIME_WAIT状态需要经过2MSL(Maximum Segment Lifetime)才能返回到CLOSE状态？
    - 为了保证客户端发送的最后一个ACK报文能够到达服务端。若未成功到达，则服务端超时重传`FIN+ACK`报文段，客户端再重传`ACK`，并重新计时。
    - 防止已失效的连接请求报文段出现在本连接中。TIME-WAIT持续2MSL可使本连接持续的时间内所产生的所有报文段都从网络中消失，这样可使下次连接中不会出现旧的连接报文段。

<https://blog.csdn.net/weixin_46833747/article/details/107775859>

# 3. 网络层

# 4. 链路层
