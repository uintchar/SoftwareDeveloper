- [1. 编译内存相关](#1-编译内存相关)
  - [1.1. C/C++程序的编译过程](#11-cc程序的编译过程)
    - [1.1.1. 编译的具体过程](#111-编译的具体过程)
    - [1.1.2. 未声明的引用和未定义的引用错误](#112-未声明的引用和未定义的引用错误)
    - [1.1.3. 静态链接和动态链接的区别](#113-静态链接和动态链接的区别)
    - [1.1.4. `extern C`的作用](#114-extern-c的作用)
  - [1.2. C/C++内存管理](#12-cc内存管理)
    - [1.2.1. 内存布局](#121-内存布局)
    - [1.2.2. 变量的作用域和生命周期](#122-变量的作用域和生命周期)
    - [1.2.3. 内存对齐](#123-内存对齐)
    - [1.2.4. 内存泄露](#124-内存泄露)
  - [1.3. 智能指针](#13-智能指针)
    - [1.3.1. 智能指针有哪几种？](#131-智能指针有哪几种)
    - [1.3.2. 使用智能指针造成的循环引用问题](#132-使用智能指针造成的循环引用问题)
    - [1.3.3. 智能指针的实现原理（代码实现）](#133-智能指针的实现原理代码实现)
- [2. 关键字和库函数](#2-关键字和库函数)
  - [2.1. `static`关键字](#21-static关键字)
  - [2.2. `const` 和 `#define`](#22-const-和-define)
  - [2.3. `inline` 和 `#define`](#23-inline-和-define)
  - [2.4. `malloc/new` 和 `free/delete`](#24-mallocnew-和-freedelete)
  - [2.5. `struct`, `union` 和 `class`](#25-struct-union-和-class)
  - [2.6. `volatile`](#26-volatile)
  - [2.7. `using` 和 `typedef`](#27-using-和-typedef)
  - [2.8. `explicit`](#28-explicit)
  - [2.9. 其他](#29-其他)
- [3. 语言对比](#3-语言对比)
  - [3.1. `C`和`C++`的区别](#31-c和c的区别)
  - [3.2. `Java`和`C++`的区别](#32-java和c的区别)
  - [3.3. `Python`和`C++`的区别](#33-python和c的区别)
  - [3.4. C++11新特性](#34-c11新特性)
    - [3.4.1. `lambda`表达式和函数对象](#341-lambda表达式和函数对象)
    - [3.4.2. `nullptr` 和 `nullptr_t`](#342-nullptr-和-nullptr_t)
    - [3.4.3. `auto` 和 `decltype` 自动类型推导](#343-auto-和-decltype-自动类型推导)
    - [3.4.4. 范围`for`循环](#344-范围for循环)
    - [3.4.5. 初始化列表](#345-初始化列表)
    - [3.4.6. 右值引用和移动语义](#346-右值引用和移动语义)
- [4. 面向对象](#4-面向对象)
  - [4.1. 面向过程和面向对象](#41-面向过程和面向对象)
  - [4.2. 面向对象的三大特性](#42-面向对象的三大特性)
  - [4.3. 面向对象的原则](#43-面向对象的原则)
  - [4.4. 重载、重写、隐藏的区别](#44-重载重写隐藏的区别)
  - [4.5. 多态及其实现](#45-多态及其实现)
- [5. 类相关](#5-类相关)
  - [5.1. 类中默认生成的函数](#51-类中默认生成的函数)
  - [5.2. 虚函数](#52-虚函数)
  - [5.3. 多重继承和虚基类](#53-多重继承和虚基类)
  - [5.4. 其他](#54-其他)
- [6. 语言特性相关](#6-语言特性相关)
  - [6.1. C++11 中的类型转换](#61-c11-中的类型转换)
  - [6.2. 其他](#62-其他)
- [7. STL](#7-stl)
- [8. 设计模式](#8-设计模式)

# 1. 编译内存相关

## 1.1. C/C++程序的编译过程

### 1.1.1. 编译的具体过程

- **预处理：** 处理以`#`开头的预处理指令，进行简单的字符串替换工作；
- **编译：** 主要进行词法分析、语法分析、语义分析等，将源码`.cpp`文件翻译成`.s`汇编代码；
- **汇编：** 将汇编代码`.s`文件翻译成机器指令生成`.o`目标文件；
- **链接：** 将生成的目标文件和库文件连接成一个整体，从而生成可执行的程序`.exe`文件。

### 1.1.2. 未声明的引用和未定义的引用错误

- 未声明的引用：出现在编译阶段；
- 未定义的引用：出现在链接阶段，因为C/C++编译生成目标文件的时候并不需要函数的具体实现，只需要有函数的原型即可。但是在链接生成可执行文件的时候，需要找到函数的具体实现；

### 1.1.3. 静态链接和动态链接的区别

- **静态链接**
  - 在编译的链接阶段，由链接器将静态库的相应内容加入到可执行程序中的做法叫静态链接。
  - 静态链接库，Windows下以`.lib`为后缀，Linux下以`.a`为后缀；
  - 缺点：
    - 浪费空间：每个可执行程序都会有目标文件的一个副本；
    - 更新困难：如果目标文件进行了更新操作，就需要重新进行编译链接生成可执行程序；
  - 优点：
    - 执行的时候运行速度快，因为可执行程序具备了程序运行的所有内容；
- **动态链接**
  - 在可执行文件装载时或程序运行时，由操作系统的装载程序加载动态库的做法称为动态链接。
  - 动态链接库，Windows下以`.dll`为后缀，Linux下以`.so`为后缀；
  - 缺点：
    - 性能损失：动态链接在程序运行时进行，每次执行都需要链接，相比静态链接会有一定的性能损失
  - 优点：
    - 节省内存、更新方便；

### 1.1.4. `extern C`的作用

- 指定C++编译器按C编译器的方式去编译生成函数符号名字；
- 当混合C/C++编程时，会遇到第三方库是C库，库中提供的符号（比如函数名称）都是按C编译器生成的，没有经过命名混淆；但是C++编译器在编译时会进行命名混淆，使得生成的符号名字与C库中的符号名字不同，因此会出现未定义的引用；

## 1.2. C/C++内存管理

### 1.2.1. 内存布局

- **栈**
  - 存放内容：存放程序的局部变量、函数参数、返回地址等；
  - 分配方式：由操作系统进行分配和释放。在分配栈空间时，如果剩余空间大于申请空间则分配成功，否则分配失败栈溢出；
  - 布局方式：栈在内存中是连续的一块空间（由高地址向低地址扩展）最大容量是系统预定好的；
- **堆**
  - 存放内容：由程序员控制；
  - 分配方式：由程序员主动进行分配和释放，通过`malloc`或`new`进行分配，`free`或`delete`进行释放，如果程序执行结束还没有释放，操作系统会自动回收。在分配堆空间时，堆在内存中呈现的方式类似于链表（记录空闲地址空间的链表），在链表上寻找第一个大于申请空间的节点分配给程序，将该节点从链表中删除。大多数系统中该块空间的首地址存放的是本次分配空间的大小，便于释放，将该块空间上的剩余空间再次连接在空闲链表上；
  - 布局方式：堆在内存中的空间（由低地址向高地址扩展）是不连续的；
- **全局区/静态存储区（`.bss`段和`.data`段）**
  - 存放内容：全局变量和静态变量。在 C 语言中，未初始化的放在`.bss`段，初始化的放在`.data`段，C++中不再区分；一般在初始化时`.bss`段部分将会清零；
  - 分配方式：由操作系统进行分配，程序运行结束操作系统自动释放；
- **常量存储区（`.data`段）**
  - 存放内容：存放的是常量，不允许修改，
  - 分配方式：由操作系统进行分配，程序运行结束操作系统自动释放；
- **代码区（`.text`段）**
  - 存放内容：存放代码，不允许修改，但可以执行。编译后的二进制文件存放在这里；
  - 分配方式：由操作系统进行分配，程序运行结束操作系统自动释放；
- **总体布局**
  - 从操作系统的本身来讲，在内存中，从低地址到高地址：`.text`段 --> `.data`段 --> `.bss`段 --> `堆` --> `unused` --> 栈 --> `env`；

### 1.2.2. 变量的作用域和生命周期

- **变量的区别**
  - 生命周期：从创建到程序运行结束，所存在的代码段；
  - 作用域：全局（单文件、多文件）、局部；

- **全局变量定义在头文件中有什么问题？**
  - 当多个源文件包含了该头文件时，会带来变量的重复定义问题；
  - 但若是`static`全局变量或`const`变量，则不会出现重复定义的问题；

### 1.2.3. 内存对齐

- **目的**
  - 提高内存访问效率，比如 intel 32 位 cpu，每个总线周期都是从偶地址开始读取32位的内存数据，如果数据存放地址不是从偶数开始，则可能出现需要两个总线周期才能读取到想要的数据；
- **规则**
  - 对于结构体的各成员变量，第一个成员的偏移量是0，后续成员的偏移量为该成员类型所占字节数的整倍数；
  - 结构体在完成所有数据成员各自的内存对齐后，结构体本身还要进行一次内存对齐，即保证整个结构体的大小为最大数据成员的最小整数倍；
  - 可以使用`#pragma pack(n)`预编译指令来指定所有成员对齐以`n`字节为准(即偏移量是n的整数倍)，不再考虑当前类型以及最大结构体内类型；

### 1.2.4. 内存泄露

- **概念**
  - 指因为疏忽或错误造成程序未能释放已经不再使用的内存的情况。内存泄漏并不是指内存在物理上的消失，而是应用程序分配某段内存后，因为设计错误，失去了对该段内存的控制，因而造成了内存的浪费。
- **C/C++程序中一般我们关心两种方面的内存泄漏**
  - 堆内存泄漏：指程序通过`malloc/calloc/realloc/new`等从堆中分配的内存，使用完毕后没有使用相应的`free/delete`来释放掉；
  - 系统资源泄漏：指程序使用系统分配的资源，比方套接字、文件描述符、管道等没有使用对应的函数释放掉，导致系统资源的浪费；

- **怎么防止内存泄漏？**
  - 程序员要养成良好习惯，保证`malloc/new`和`free/delete`匹配；
  - 使用智能指针来管理资源；
  - 使用内存泄漏检测工具；

- **内存泄漏检测工具的原理？**
  - 检查`malloc/new`和`free/delete`是否匹配，一些工具也就是这个原理。要做到这点，就是利用宏或者钩子，在用户程序与运行库之间加了一层，用于记录内存分配情况；

## 1.3. 智能指针

### 1.3.1. 智能指针有哪几种？

- **概念**
  - 智能指针是模板类，负责自动释放所指向的对象（在类的析构函数中释放资源）；
  - 智能指针是栈上的对象，采用栈上的指针去管理堆上的内容，从而使得堆上的对象随着栈上对象销毁时自动销毁；
  - 为了使得智能指针能够具有指针的行为，需要在类中重载 `*`、`->`、`bool` 运算符；

- **`auto_ptr`**
  - 概述：独占所指向的对象，被 C++ 11 弃用；
  - 初始化：通过构造函数初始化；
  - 拷贝和赋值：进行拷贝或赋值后所有权发生转移；
  - 相关方法：
    - `T *get()`：返回类中的指针；
    - `T *release()`：放弃对指针的控制权，返回类中指针，并将其置为空；
    - `swap`：分为成员函数版`void swap(auto_ptr &rhs)`和非成员函数版`template <typename T> void swap(auto_ptr<T> &lhs, auto_ptr<T> &rhs)`，交换两者的指针成员；
    - `void reset(T *q = nullptr)`：如果提供了内置指针`q`，则将类中指针指向q所指向的对象，否则将类中指针置空;
  - 不能管理数组（析构调用`delete`）；
  - 不能作为容器对象，STL容器中的元素经常要支持拷贝，赋值等操作，在这过程中`auto_ptr`会传递所有权，那么source与sink元素之间就不等价了；

- **`unique_ptr`**
  - 概述：独占所指向的对象；
  - 初始化：通过构造函数初始化（传入的指针应已预先分配内存）；
  - 拷贝和赋值：禁止拷贝和赋值，但是可以通过移动语义（移动构造函数、移动赋值运算符、`std::move`）转移所有权；
  - 相关方法：`get`、`release`、`swap`、`reset`；
  - 可以管理数组（析构默认调用 `delete`，可以向其传递专门制定的删除器）；
  - 为了实现子类指针向基类指针的隐式转换，需要编写带模板的移动构造函数和移动赋值运算符；

- **`shared_ptr`**
  - 概述：允许多个指针指向同一个对象，使用引用计数的机制管理对象
  - 初始化：可以通过构造函数初始化，也可以使用`make_shared`函数初始化
  - 拷贝和赋值：拷贝使得对象的引用计数增加1，赋值使得赋值左边对象引用计数减1，当计数为0时，自动释放内存，赋值右边对象引用计数加1，指向后来的对象
  - 相关方法：`use_count`, `swap`；
  - 可以向其传递专门制定的删除器；

- **`weak_ptr`**
  - 概述：伴随类，是一种弱引用，指向`shared_ptr`所管理的对象
  - 初始化：可以从一个 `shared_ptr` 或者另一个 `weak_ptr` 对象构造，不能使用 `new` 对象进行构造。`weak_ptr` 的构造不会引起引用计数的增加；
  - 拷贝和赋值：不会引起引用计数的增加；
  - 相关方法：
    - 没有重载 `operator*` 和 `operator->` ，它的最大作用在于协助 `shared_ptr` 工作；
    - `use_count()`：可以观测资源的引用计数；
    - `expired()`：等价于 `use_count()==0` 但更快，表示被观测的资源(也就是`shared_ptr`的管理的资源)已经不复存在；
    - `lock()`：从被观测的`shared_ptr`获得一个可用的`shared_ptr`对象，从而操作资源。但当`expired()==true` 的时候，`lock()` 函数将返回一个存储空指针的 `shared_ptr` ；

### 1.3.2. 使用智能指针造成的循环引用问题

- 循环引用（两个其实已经没有被使用的对象彼此互指，使之看似还在“被使用”的状态）的问题；`shared_ptr`带来的一个最大的问题是循环引用，循环引用会导致堆内存无法正确释放，导致内存泄漏；
- 解决：使用`weak_ptr`；

### 1.3.3. 智能指针的实现原理（代码实现）

# 2. 关键字和库函数

## 2.1. `static`关键字

- **修饰类外变量**
  - 说明该变量为静态变量，其存储区域为静态区，生命周期为从变量定义开始到程序结束；
  - 静态局部变量：空间只分配一次，前一次函数调用后的变量值保持到下一次函数调用；
  - 静态全局变量：其作用域仅为本文件内，相比于普通全局变量，不能通过`extern`关键字使其在其他文件中也能使用；

- **修饰类外函数**
  - `static` 函数的作用域仅为本文件内，非 `static` 函数的作用域为多文件；

- **修饰类的数据成员**
  - 作用：说明该成员属于该类的全体对象共有，存储在静态区；其生命周期不依赖于任何对象，从定义处开始直到程序结束；
  - 初始化：非 `const int` 类型的静态成员变量需要在类外单独进行初始化，`Type className::VarName = value`；
  - 使用：既可以通过类名直接访问公有静态成员变量，也可以通过对象名访问公有静态成员变量；

- **修饰类的函数成员**
  - 说明该成员属于类的全体对象共有，且没有 `this` 指针；
  - 只能直接访问静态成员变量和静态成员函数，不能访问非静态成员；
  - 既可以通过类名直接访问类的公有静态成员函数，也可以通过对象名访问类的公有静态成员函数；
  - 不能是虚函数，虚函数依靠 `vptr` 和 `vtable` 来处理。`vptr` 是一个指针，在类的构造函数中创建生成，并且只能用 `this` 指针来访问它，因为它是类的一个成员，并且`vptr`指向保存虚函数地址的`vtable`；

- **普通成员函数**
  - 属于类的全体对象共有，含有`this`指针；
  - 既可以访问静态成员变量和静态成员函数，又可以访问非静态成员；
  - 只可以通过对象名访问类的公有普通成员函数，不可以通过类名直接访问类的公有普通成员函数；

## 2.2. `const` 和 `#define`

- `const` 修饰变量或对象，说明该变量或对象不可修改，其定义时必须进行初始化；

- `cosnt` 全局对象默认的作用域为本文件内，所以可以在多文件内定义同名的 `const` 全局对象，即可以在头文件内定义一个 `const` 对象；

- `const` 和指针
  - 若 `const` 位于 `*` 的左侧，说明其为指向常量的指针，如：`const int *p; int const *p` ；
  - 若 `const` 位于 `*` 的右侧，说明其为常量指针，如：`int * const p` ；

- `const` 和类
  - 在类中，任何不会修改数据成员的函数成员都应该声明为 `const` 类型，即常成员函数；
  - 只有常成员函数才能操作常量对象；
  - 类中的 `const` 数据成员必须通过列表初始化；

- `const`常量 和 `#define` 常量的区别
  - `const` 常量具有类型，编译器可以进行安全检查；`#define` 宏定义没有数据类型，只是进行简单的字符串替换，不能进行安全检查。

## 2.3. `inline` 和 `#define`

- `inline`工作原理
  - 内联指的是编译器在函数调用点处通过函数的实参把函数代码直接展开，节省了函数调用开销；
  - 但是如果内联函数的执行时间本身就比函数调用的开销要大，则内联并不能提高较大效率；

- 内联和虚函数
  - 虚函数可以是内联函数，但是当虚函数表现出多态性的时候不能内联；
  - 内联是在编译期建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联；

- 宏定义（`#define`）和内联函数（`inline`）的区别
  - 处理时期不同：宏 `#define` 在预处理时期完成，只是进行简单的字符串替换；内联在编译时期完成，即在函数的调用点，通过函数的实参把函数代码直接展开，节省了函数调用的开销；
  - 调试性质不同：宏是没有办法进行调试的，但是内联函数是可以调试的；

- 用宏实现比较大小，以及两个数中的最大值
  - `#define MAX(X, Y) ((X)>(Y)?(X):(Y))`

## 2.4. `malloc/new` 和 `free/delete`

- `new` 和 `malloc` 如何判断是否申请到内存？
  - `malloc`通过返回值是否为`NULL`判断；
  - `new` 通过是否抛出异常？？？

- `malloc` 和 `free` 的底层实现？
  - 系统调用；
  - `malloc` 在空闲区链表中找到第一个大于申请内存大小的节点，并将其从链表中删除；
  - `free` 往空闲区链表中插入一个新的节点，可能涉及到链表节点的合并操作；

- `new` 和`malloc` 的区别，`delete` 和 `free` 的区别
  - `new/delete` 是C++关键字，需要编译器支持；`malloc/free` 是库函数，需要头文件支持；
  - `new` 内存分配失败时，会抛出 `bac_alloc` 异常; `malloc`分配内存失败时返回 `NULL` ；
  - `new` 内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故 `new` 是符合类型安全性的操作符; `malloc` 内存分配成功时，返回的是 `void *` ，需要通过强制类型转换将 `void *` 指针转换成我们需要的类型；
  - `new` 内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算；而 `malloc` 则需要显式地指出所需内存的大小；
  - `new` 会先调用 `operator new` 函数，申请足够的内存（通常底层使用 `malloc` 实现），然后调用类的构造函数，初始化成员变量，最后返回自定义类型指针；`delete` 先调用析构函数，然后调用`operator delete` 函数释放内存（通常底层使用 `free` 实现）。而 `malloc` 和 `delete` 是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作；
  - `new` 从自由存储区上为对象动态分配内存空间，而 `malloc` 函数从堆上动态分配内存。自由存储区是 C++ 基于 `new` 操作符的一个抽象概念，凡是通过 `new` 操作符进行内存申请，该内存即为自由存储区。而堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C语言使用 `malloc` 从堆上分配内存，使用 `free` 释放已分配的对应内存。自由存储区不等于堆，如上所述，布局 `new` 就可以不位于堆中；
  - 内存泄漏对于 `new` 和 `malloc` 都能检测出来，而 `new` 可以指明是哪个文件的哪一行，`malloc`不可以；
  - C++ 允许自定义 `operator new` 和 `operator delete` 函数控制动态内存的分配；

## 2.5. `struct`, `union` 和 `class`

- C 和 C++ `struct`的区别？
  - C++ 中 `struct` 本质上是一个类，既可以包含成员变量，又可以包含成员函数；
  - C++ 中 `struct` 的成员默认访问权限是 `public` 的，而 `class` 的成员默认访问权限是 `private` 的；
  - 在 C++ 中保留 `struct` 的主要目的是为了保持和 C 语言的兼容性；

- `struct` 和 `union` 的区别
  - `union` 是一种节省空间的特殊的类，一个 `union` 的多个数据成员共用同一块内存（最大数据成员所占的内存），在任意时刻只有一个数据成员可以有值。当某个成员被赋值后其他成员变为未定义状态。联合有如下特点：
  - 默认访问控制符为 `public`；
  - 可以含有构造函数、析构函数；
  - 不能含有引用类型的成员；
  - 不能继承自其他类，不能作为基类；
  - 不能含有虚函数；
  - 匿名 `union` 在定义所在作用域可直接访问 `union` 成员；
  - 匿名 `union` 不能包含 `protected` 成员或 `private` 成员；
  - 全局匿名联合必须是 `static` 的;

## 2.6. `volatile`

- `volatile` 告诉编译器不要对可能频繁发生变化的变量进行优化（因为这个变量可能被其他线程修改），即每次访问变量时都必须从内存中取出值，而不要从 CPU 寄存器中取值；

- `volatile` 只能保证读取变量时具有原子性，而不保证读-改-写这三步的原子性；

- `volatile` 可以和 `const` 一起使用，比如只读的状态寄存器；

- 指针可以是 `volatile`

## 2.7. `using` 和 `typedef`

## 2.8. `explicit`

- 修饰单参数的构造函数，可以防止单参数向类的隐式类型转换；

## 2.9. 其他

- `sizeof`和`strlen`的区别
  - `sizeof` 是关键字，在编译期执行，获得类型所占的字节数；
  - `strlen` 是函数调用，在运行期执行，获得以 `\0` 结尾的字符串的长度；

- `sizeof(1==1)`在`C`和`C++`中分别是什么结果？

- `memcpy`函数的底层原理？

- `strcpy`函数有什么缺陷？

- `auto`类型推导的原理

# 3. 语言对比

## 3.1. `C`和`C++`的区别

## 3.2. `Java`和`C++`的区别

## 3.3. `Python`和`C++`的区别

## 3.4. C++11新特性

### 3.4.1. `lambda`表达式和函数对象

- `lambda`表达式：`[](args) -> {}`
- 仿函数（functor）又称为函数对象（function object）是一个能行使函数功能的类，在类内重载`operator()`运算符；
- 编译器会把一个lambda表达式生成一个匿名类的匿名对象，并在类中重载函数调用运算符，实现了一个`operator()`方法。

### 3.4.2. `nullptr` 和 `nullptr_t`

- 传统 C++ 把`NULL、0`视为同一种东西，这可能会导致 C++ 中重载特性发生混乱，比如`func(NULL)`的本意为调用使用指针形参的函数版本，但是实际可能调用的是`int`形参的函数版本；
- `nullptr`的类型为`nullptr_t`，能够隐式的转换为任何类型的指针，也能和他们进行相等或者不等的比较；
- C++ 不允许直接将`void *`隐式转换到其他类型，如果`NULL`被定义为`((void*)0)`，那么当编译`char *ch = NULL;`时，`NULL`只好被定义为`0`；

### 3.4.3. `auto` 和 `decltype` 自动类型推导

- `auto` 和 `decltype`类型推导：编译器在编译期间根据上下文自动推导出变量的类型；
- `auto` 根据 `=` 右边的初始值 `value` 推导出变量的类型；`decltype`根据`exp`表达式推导出变量的类型，跟`=`右边的`value`没有关系；

### 3.4.4. 范围`for`循环

### 3.4.5. 初始化列表

### 3.4.6. 右值引用和移动语义

# 4. 面向对象

## 4.1. 面向过程和面向对象

- 面向过程是一种以过程为中心的编程思想，其原理就是将问题分解成一个一个具体的处理步骤，然后通过函数实现每一个步骤，并依次调用。面向过程我们所关心的是解决一个问题的步骤，举个例子，汽车发动、汽车熄火，这是两个不同的事件，对于面向过程而言，我们关心的是事件本身，因此我们会使用两个函数完成以上两个动作，然后依次调用即可；

- 面向对象则是一种以对象为中心的编程思想，就是通过分析问题，分解出一个一个的对象，然后通过不同对象之间的调用来组合解决问题。建立对象的目的不是为了完成某个步骤，而是为了描述某个事物在解决整个问题的过程中的行为。如上面的例子，汽车发动、汽车熄火，对于面向对象而言，我们则关心的是汽车这类对象，两个事件只是这类对象所具备的行为；

## 4.2. 面向对象的三大特性

- **封装**
  - 概念：将一个类的某些信息隐藏在类的内部，不允许外界直接访问，而是提供某些方法实现对隐藏信息的访问和操作。
  - 好处：
    - 增强了数据安全性；
    - 隐藏了类的实现细节，使用者无需了解具体实现细节，只需通过特定的接口进行访问；
    - 方便类自身的实现和修改；

- **继承**
  - 概念：继承是类与类之间的一种关系，即子类继承父类的属性和行为，使得子类具有和父类相同的属性和行为。
  - 好处：子类继承了父类的属性和方法从而实现了代码的复用；

- **多态**
  - 概念：指调用相同方法在不同情形下有不同的表现形式；
  - 好处：使得具有不同内部结构的对象可以共享相同的外部接口；

## 4.3. 面向对象的原则

- **单一职责原则**
  - 概念：一个对象应该只包含单一的职责，并且该职责被完整地封装在一个类中。就一个类而言，应该仅有一个引起它变化的原因；
  - 目的：软件设计过程中，如果一个类承担的职责越多，那么它被复用的可能性越小。另一方面，如果一个类承担的职责越多，各个职责耦合在一起，修改其中一个职责可能“牵一发而动全身”；高内聚，低耦合。
  - 方法：将职责进行分离，不同的职责封装在不同的类中。

- **开放封闭闭原则（Open Close Principle）**
  - 概念：对扩展开放，对修改关闭。在程序需要进行拓展的时，不能去修改原有的代码，实现一个热插拔的效果；
  - 目的：为了使程序的扩展性好，易于维护和升级；
  - 方法：使用接口和抽象类。

- **里氏代换原则（Liskov Substitution Principle）**
  - 概念：任何基类可以出现的地方，子类一定可以出现；
  - 目的：LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充；
  - 方法：实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。

- **依赖倒转原则（Dependence Inversion Principle）**
  - 概念：针对接口编程，不要针对实现编程。高层模块不应该依赖低层模块，它们都应该依赖抽象。抽象不应该依赖于细节，细节应该依赖于抽象

- **接口隔离原则（Interface Segregation Principle）**
  - 概念：使用多个隔离的接口，比使用单个接口要好。客户端不应该依赖那些它不需要的接口；
  - 目的：降低类之间的耦合度。

- **迪米特法则，又称最少知道原则（Demeter Principle）**
  - 概念：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。

- **合成复用原则（Composite Reuse Principle）**
  - 概念：尽量使用关联、聚合、组合的方式，而不是使用继承来达到复用的目的。
  - 目的：对象组合可以使系统更加灵活（黑箱复用），降低类与类之间的耦合度，一个类的变化尽可能不影响其他类。如果要使用继承，则需考虑里氏代换原则和依赖倒转原则。继承关系会破坏系统的封装性，会将基类的实现细节暴露给子类（白箱复用），如果基类发生改变，那么子类的实现也不得不改变。

## 4.4. 重载、重写、隐藏的区别

- **重载**
  - 同一作用域内，同名的函数具有不同的形参（数量、顺序）构成函数重载；
  - 函数返回值类型与构成重载无任何关系；
  - 类的静态成员函数与普通成员函数可以形成重载；
  - 函数重载发生在同一作用域，如类成员函数之间的重载、全局函数之间的重载；

- **隐藏**
  - 指不同作用域中定义的同名函数构成隐藏（不要求函数返回值和函数参数类型相同）。比如派生类成员函数隐藏与其同名的基类成员函数、类成员函数隐藏全局外部函数。

- **重写**
  - 派生类中与基类同返回值类型、同名和同参数的虚函数重定义，构成虚函数覆盖，也叫虚函数重写；

- 隐藏是一个静态概念，它代表了标识符之间的一种屏蔽现象，而重写覆盖则是为了实现动态联编，是一个动态概念；

## 4.5. 多态及其实现

# 5. 类相关

## 5.1. 类中默认生成的函数

- **默认构造函数**
  - 生成规则和 C++98 一样，在用户没有声明自定义的构造函数的时候并且编译期需要的时候生成；

- **析构函数**
  - 生成规则和 C++98 一样，在 C++11 中有点不同的是，析构函数默认是noexcept。

- **拷贝构造函数**
  - 用户自定义了移动操作会导致不生成默认的拷贝构造函数，其它和 C++98 的行为一致；

- **拷贝赋值操作符**
  - 用户自定义了移动操作会导致不生成默认的拷贝赋值操作，其它和 C++98 的行为一致；

- **移动构造函数和移动赋值操作符**
  - 仅仅在没有用户自定义的拷贝操作，移动操作和析构操作的时候才会生成。

- 根据《Effective Modern C++》Item17 P115页提到，当类中含有特殊成员函数变为模板特殊成员函数的时候,此时不满足上述生成规则，也就是针对当前例子来说，编译器会默认生成拷贝构造，所以此时上述main调用里面为error的都可以正常运行！

## 5.2. 虚函数

1. 什么是虚函数？什么是纯虚函数？
   - 类中用`virtual`修饰的成员函数称为虚函数；
   - 纯虚函数是一种特殊的虚函数`=0`，在基类中不能对虚函数给出有意义的实现，而把它声明为纯虚函数，它的实现留给该基类的派生类去做；

2. 虚函数和纯虚函数的区别？
   - 类里如果声明了虚函数，这个函数是实现的，哪怕是空实现，它的作用就是为了能让这个函数在它的子类里面可以被覆盖（override），这样的话，编译器就可以使用后期绑定来达到多态了。纯虚函数只是一个接口，是个函数的声明而已，它要留到子类里去实现；
   - 虚函数在子类里面可以不重写；但纯虚函数必须在子类实现才可以实例化子类；
   - 虚函数的类用于“实作继承”，继承接口的同时也继承了父类的实现。纯虚函数关注的是接口的统一性，实现由子类完成；
   - 带纯虚函数的类叫抽象类，这种类不能直接生成对象，而只有被继承，并重写其虚函数后，才能使用。抽象类被继承后，子类可以继续是抽象类，也可以是普通类；
   - 虚基类是虚继承中的基类，具体见下文虚继承；

3. 虚函数的实现机制
   - 虚函数指针与虚函数表；

4. 单继承和多继承的虚函数表结构
   - 单继承：只有一个虚函数表，父类的虚函数在前，子类的虚函数在后；当发生虚函数重写时，父类虚函数被覆盖；
   - 多继承：每一个父类对应一个虚函数表，子类的虚函数存放在第一个父类对应的虚函数表中，同样是父类的虚函数在前，子类的虚函数在后；

5. 构造函数、析构函数是否需要定义成虚函数？为什么？
   - 构造函数不可以是虚函数，因为调用构造函数时，虚表指针并没有在对象的内存空间中，必须要构造函数调用完成后才会形成虚表指针；
   - 析构可以是虚函数，用于解决基类的指针或引用指向派生类对象，并用基类的指针销毁派生类对象，这时应该调用派生类的析构函数来释放派生类对象；

## 5.3. 多重继承和虚基类

- 访问的二义性，浪费存储空间（菱形继承）；
- 当子类继承的两个父类中拥有同名变量时，可以使用作用域运算符来区分同名变量；
- 当出现菱形继承时，可采用虚继承来解决：
  - 对于虚继承，子类中将只有一份基类的成员的拷贝；
  - 子类通过`vbptr`虚基类表指针（virtual base table pointer）来对基类成员进行访问，该指针指向了一个虚表（virtual table），虚表中记录了`vbptr`与本类的偏移地址；第二项是`vbptr`到共有基类元素之间的偏移量；

## 5.4. 其他

1. 类的大小`sizeof`
    - 空类型（类定义里没有任何成员变量和成员函数），大小为1字节。因为当我们声明一个类型的实例时，它在内存中必须占有一定的空间，否则无法使用这些实例，至于占用多少内存，由编译器决定。
    - 类中含有虚函数时，编译器会为该类型生成一个虚函数表，并隐式地为该类型的每一个对象添加一个指向虚函数表的指针，所以此时`sizeof`该类型得到的结果为指针在该机器中所占的字节数；
    - C++为了兼容C，保留了`struct`关键字，但是实际上C++中的`struct`是一个默认访问控制权限为`public`的`class`。C++标准规定：一个空类的大小为1个字节，因此在C++中，`sizeof(空类或空结构体) = 1`，在C语言中，`sizeof(空结构体) = 0`；
  
2. 如何禁止构造函数的使用？

3. 如何避免拷贝？

4. 如何减少构造函数开销？

5. 为什么拷贝构造函数必须为引用？

6. C++ 类对象的初始化顺序

7. 如何禁止一个类被实例化？
    - 将类定义为抽象类；
    - 将构造函数定义为`private`；

8. 为什么用成员初始化列表会快一些？
    - 在类的构造函数中，不在函数体内对成员变量赋值，而是在构造函数的花括号前面使用冒号和初始化列表赋值；
    - 当类中包含其他类对象时，使用成员初始化列表可以使得在类的构造时就直接对类对象进行初始化，而不需进入构造函数的函数体内调用诸如赋值运算符或其它额外的构造函数的过程；

9. 实例化一个对象需要哪几个阶段

10. 友元函数的作用及使用场景

11. 静态绑定和动态绑定是怎么实现的？

12. 深拷贝和浅拷贝的区别

13. 编译时多态和运行时多态的区别

14. 实现一个类成员函数，要求不允许修改类的成员变量？

15. 如何让类不能被继承？

16. 如何定义一个只能在堆上生成对象的类？
    - 方法：将析构函数设为私有；
    - 原因：C++是静态绑定语言，编译器管理栈上对象的生命周期，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性。若析构函数不可访问，则不能在栈上创建对象。

17. 如何定义一个只能在栈上生成对象的类？
    - 方法：将`new`和`delete`重载为私有；
    - 原因：在堆上生成对象，使用`new`关键词操作，其过程分为两阶段：第一阶段，使用`new`在堆上寻找可用内存，分配给对象；第二阶段，调用构造函数生成对象。将`new`操作设置为私有，那么第一阶段就无法完成，就不能够在堆上生成对象。

# 6. 语言特性相关

## 6.1. C++11 中的类型转换

- C 语言中强制类型转换的缺点
  - 过于粗暴：任意类型之间都可以进行转换，编译器很难准确判断正确性；
  - 难于定位：在源码中无法快速定位所有使用强制类型转换的语句；

- `static_cast`
  - 用于进行比较 “自然” 和低风险的转换，如整型和浮点型、整型和字符型之间的互相转换、`void*` 指针转换为其他类型指针；
  - 不能用于在不同类型的指针之间互相转换、整型和指针之间的互相转换、不同类型的引用之间的转换；
  - 用于有继承关系的类之间的转换
    - 进行上行转换（把派生类的指针或引用转换成基类表示）是安全的；
    - 进行下行转换（把基类的指针或引用转换为派生类表示），由于没有动态类型检查，所以是不安全的；

- `dynamic_cast`
  - 主要用于类层次结构中基类（父类）和派生类（子类）之间指针或引用的转换；
  - 用于有交叉关系的类指针间的转换；
  - 向下转换时，具有类型检查；
  - 对不明确的指针转换将失败（返回 `nullptr` ），但不引发异常；

- `const_cast`
  - 用于删除`const`、`volatile` 和 `__unaligned`特性（如将`const int`类型转换为`int`类型）

- `reinterpret_cast`
  - 用于不同类型指针之间的转换，如 `char* -> int*`, `One_class* -> Unrelated_class*`，但其本身并不安全；
  - 用于整数类型和指针类型之间的转换；
  - 不能丢掉 `const` 、 `volatile` 或 `__unaligned` 特性；
  - 一个实际用途是在哈希函数中，即，通过让两个不同的值几乎不以相同的索引结尾的方式将值映射到索引；

## 6.2. 其他

1. 左值和右值的区别？左值引用和右值引用的区别，如何将左值转换成右值？

2. `std::move()`函数的实现原理

3. 什么是指针？指针的大小及用法？

4. 什么是野指针和悬空指针？
   - 野指针：指针定义时，未初始化，导致其指向一段随机的内存；
   - 悬空指针：指针定义时正常初始化，但是在使用`delete`释放该指针指向的内存后，没有将该指针置空；

5. C++ 11 `nullptr` 比 `NULL` 优势

6. 指针和引用的区别？
   - 引用是对象的别名，其在定义时一定要进行初始化，即绑定一个特定的对象，并且其后不能再重新绑定到另外一个对象；
   - 指针是正常的对象，其在定义时可以不进行初始化，也可以改变指针对象的值；
   - 可以把引用看作是一个常量指针；

7. 常量指针和指针常量的区别

8. 函数指针和指针函数的区别

9. 如何判断结构体是否相等？能否用`memcmp`函数判断结构体相等？

10. 参数传递时，值传递、引用传递、指针传递的区别？

11. 什么是模板？如何实现？

12. 函数模板和类模板的区别？

13. 什么是可变参数模板？

14. 什么是模板特化？为什么特化？

15. `include " "` 和 `#include <>` 的区别

16. `switch` 的 `case` 里为何不能定义变量
    - 变量的初始化会因为有时候`case`条件不被执行而跳过；

17. 迭代器的作用？

18. 泛型编程如何实现？

19. 什么是类型萃取？

# 7. STL

# 8. 设计模式

1. 了解哪些设计模式？

2. 什么是单例模式？如何实现？应用场景？
   - 定义：
     - 指一个类只有一个实例，且该类能自行创建这个实例的一种模式。例如，Windows 中只能打开一个任务管理器，这样可以避免因打开多个任务管理器窗口而造成内存资源的浪费，或出现各个窗口显示内容的不一致等错误。
   - 应用场景：
     - 需要频繁创建的一些类，使用单例可以降低系统的内存压力，减少 GC。
     - 某类只要求生成一个对象的时候，如一个班中的班长、每个人的身份证号等。
     - 某些类创建实例时占用资源较多，或实例化耗时较长，且经常使用。
     - 某类需要频繁实例化，而创建的对象又频繁被销毁的时候，如多线程的线程池、网络连接池等。
     - 频繁访问数据库或文件的对象。
     - 对于一些控制硬件级别的操作，或者从系统上来讲应当是单一控制逻辑的操作，如果有多个实例，则系统会完全乱套。
     - 当对象需要被共享的场合。由于单例模式只允许创建一个对象，共享该对象可以节省内存，并加快对象访问速度。如 Web 中的配置对象、数据库的连接池等。
   - 优点：
     - 单例模式可以保证内存里只有一个实例，减少了内存的开销；
     - 可以避免对资源的多重占用；
     - 单例模式设置全局访问点，可以优化和共享资源的访问；
   - 缺点：
     - 单例模式一般没有接口，扩展困难。如果要扩展，则除了修改原来的代码，没有第二种途径，违背开闭原则；
     - 在并发测试中，单例模式不利于代码调试。在调试过程中，如果单例中的代码没有执行完，也不能模拟生成一个新的对象；
     - 单例模式的功能代码通常写在一个类中，如果功能设计不合理，则很容易违背单一职责原则；

3. 什么是工厂模式？如何实现？应用场景？

4. 什么是观察者模式？如何实现？应用场景？
