- [1. 自我介绍](#1-自我介绍)
- [2. kjz项目](#2-kjz项目)
  - [2.1. 针对项目可能会被问到的问题](#21-针对项目可能会被问到的问题)
  - [2.2. 项目背景](#22-项目背景)
    - [2.2.1. 目标](#221-目标)
    - [2.2.2. 背景](#222-背景)
    - [2.2.3. 意义](#223-意义)
  - [2.3. 实现方法](#23-实现方法)
    - [2.3.1. 有限状态机介绍](#231-有限状态机介绍)
- [3. Massive MIMO相关项目介绍](#3-massive-mimo相关项目介绍)
- [4. 比赛介绍](#4-比赛介绍)
- [5. 别人的面经](#5-别人的面经)
  - [5.1. 阿里](#51-阿里)
  - [5.2. 字节](#52-字节)

# 1. 自我介绍

- 您好，我叫XXX，本科和硕士都就读于中国科学技术大学，目前研二。在研究生的两年里，我主要参加了两个项目，其中一个是关于 5G 接入网协议栈的嵌入式软件开发（低轨卫星通信场景下接入网协议栈的设计与实现），另一个是关于 5.5G 中物理层算法的研究（Massive MIMO 场景下物理层算法的研究）。

- 对于接入网协议栈的这个项目，项目的目标在于基于地面先进的 5G 协议体系，针对卫星移动通信信道特性、空间辐照环境和载荷硬件平台约束，进行低轨卫星通信场景下接入网协议栈的设计与实验验证。在工程实现中，前期我们基于 C 语言和 Linux 操作系统进行协议栈的软件开发及验证，后期基站侧基于 P2020 CPU 和 ReWorks 操作系统实现最终协议，终端侧基于 LC1860 和 ThreadX 操作系统实现最终协议。在这个项目中，我做的主要工作包括：

- 在 5G 接入网协议栈嵌入式软件开发的这个项目中，前期我们基于C语言（和Linux操作系统）完成了各层协议主要内容的开发工作，后期我们将把前期实现的代码移植到甲方提供的具体硬件上。在这个项目中，我做的工作主要包括：
  1. 首先，我负责 RRC（无线资源控制）层协议的软件开发工作。我参考了开源的 LTE 协议栈实现代码，将 RRC 层协议抽象成了一个有限状态机，然后使用表驱动法实现了这个状态机，表驱动法的核心在于通过保存在表里面的函数指针来完成各种具体过程的执行，从而避免了程序中出现大量`if-else`条件分支语句，并且有利于后续的程序扩展工作；
  2. 然后，我还协助其他层人员将以表驱动法实现的有限状态机的代码框架复用到其他各层协议的程序实现中；
  3. 最后，我使用 Posix 线程 API 搭建了协议栈的整体实现框架，主要是将每一层协议抽象为一个线程，并借鉴Posix 消息队列设计了专门的消息队列数据结构来进行层（线程）与层（线程）之间的通信；

- 在 5.5G 物理层算法研究（Massive MIMO场景下物理层算法研究）的这个项目中，研究的目标主要是降低大维信号处理算法的计算复杂度。在这个项目中，我做的工作主要包括：
  1. 利用信道矩阵的低秩特性，并采用随机化的算法，提出了一种性能优于传统 LS（最小二乘）估计且有效降低对大维信道矩阵进行 SVD（奇异值分解）的计算复杂度的算法，并以此发表了一篇EI文章；
  2. 针对深度学习在信道估计领域的应用进行了相关研究...

- 通过参与这两个项目，我觉得自己更喜欢软件开发这项偏工程实践的工作，并且我自己也在此期间自学了 C\C++，操作系统和设计模式等相关的软件知识，所以我希望自己以后能够在软件开发的方向进行发展。

# 2. kjz项目

## 2.1. 针对项目可能会被问到的问题

1. 为什么基于 5G 而不是 LTE ？
   - 为了和支持向 5G 的平滑演进；

2. 相对于地面 5G 协议栈，你们做出了哪些适应性改进？
   - 低轨卫星相较于地面基站传输时延更大，会对随机接入流程中上行定时提前造成影响，所以重新分析和确定了高层协议中定时提前命令(Timing Advance Command, TAC)的大小；
   - 低轨卫星移动速度大会造成频繁上行失步，本文根据实际场景和卫星能力，制定了合适的上行时间校准方案；
   - 单颗卫星和两个波束场景简单，为了提高接入效率，简化设计系统消息的类型和内容；
   - 切换相关协议设计中，由于只存在一个卫星下的波束间切换，照搬5G NR协议相关流程会造成资源浪费，且影响协议可靠性，所以从测量上报事件和切换流程上进行了适应性设计；
   - 将 MME 的 NAS 层功能搬到卫星基站上；

3. 项目中存在的难点？你是如何解决的？

4. 项目中最有技术含量的地方？

## 2.2. 项目背景

### 2.2.1. 目标

基于地面先进的 5G 协议体系，针对卫星移动通信信道特性、空间辐照环境和载荷硬件平台约束，进行低轨卫星通信场景下接入网协议栈的设计与实验验证。在工程实现中，前期我们基于 C 语言和 Linux 操作系统进行协议栈的软件开发及验证，后期基站侧基于 P2020 CPU 和 ReWorks 操作系统实现最终协议，终端侧基于 LC1860 和 ThreadX 操作系统实现最终协议。

### 2.2.2. 背景

低轨卫星相比于高轨卫星具有低时延、低成本、低损耗、可全球覆盖的特点，相比于地面系统又有着广覆盖、大容量、信道质量好的优点，其应用前景十分广阔。

5G 已经进行商用，6G 的标准化也已经开始进行。对于 6G，有一个普遍的共识是 6G 将实现天地一体化的通信网络（天地一体化信息网络是科技创新2030重大项目中第一个启动的重大工程项目）。天地一体化信息网络主要包含天基骨干网、天基接入网和地基节点网，联合了地面通信网络 ，从而实现空间信息资源的综合利用。目前，地面通信网络发展已经成熟，而通信卫星组成的天基通信网络可以充分利用移动通信卫星特有的信号辐射范围广、信号传输距离远、服务用户容量大等优点，所以逐渐被公众所重视，卫星通信网络研究和部署也就成为了新的热点。譬如通信卫星信号辐射范围广，可以节约地面通信基础设施的投资，所以由高、中和低轨道卫星组成的一层或多层通信卫星星座，广泛用于通信接入和中继、获取定位和导航、监测环境和气象等方面。除此之外，当地面上发生一些重大灾难时，受灾地区的所有地面通信设施都可能存在损坏而停止工作，此时卫星通信网络将会成为方便有力的应急通信保障。

针对天基通信网络而言，低轨卫星网络组成了天基接入网，而天基骨干网则主要由同步卫星等高轨卫星通信网络组成。从部署位置上可以看出，天基接入网处于天基骨干网和地基节点网之间，所以低轨卫星充当的是基站的作用，地面通信网络可以通过接入低轨卫星基站，进而接入天基骨干网，因此低轨卫星通信网络具有重要的地位。随着通信技术和航天运载火箭技术的飞速发展，制造和发射卫星的成本持续下降，低轨卫星通信网络具备了成本低廉和技术更新速度快等优点，成为了卫星通信领域研究中的热点。

早在上世纪80年代末，旨在搭建美国首个低轨卫星通信网络的“铱星计划”就已经被提出。近年来，国外低轨卫星通信网络的研究和部署更是如火如荼，从2012年起，以建立全球化的高速电信网络为目标的OneWeb公司，开始通过发射小型低轨卫星来组建高速的低轨卫星通信网络。OneWeb 设计的低轨卫星网络包含在轨和备份两种不同类型的卫星，共计882颗，并且这些卫星均匀地运行在高度为 $1200km$ 多个极地轨道上。同时为了保证所有覆盖区域良好的信号辐射，各个轨道上卫星将交替对用户进行无缝覆盖。除了 OneWeb 外，国外众多其他公司也紧随其后推动着低轨卫星通信网络的建设。例如在 2018 年，SpaceX 公司提出了 Starlink 星链计划，旨在搭建包含 12000 多颗卫星的巨型星座，其中包含 1584 颗是高度为 $550km$ 的低轨卫星，以便构建出上网速度高达 1GB/s 的卫星通信网络。除OneWeb、SpaceX 之外，波音、LeoSat、三星等公司也先后提出了关于构建低轨卫星通信网络的计划。

最近十年，国内低轨卫星通信网络也在飞速发展，自 2014 年开始，我国研发制造用于通信测试的第一颗低轨卫星“灵巧”成功升空，它运行在距离地面 的轨道面上，并且成功实现了所有的预期功能。之后鸿雁星座通信网络开始研究和部署，它包含54颗骨干卫星，并存在 270 个小型卫星充当补网作用，组成具有 300 颗以上卫星的星座。鸿雁星座通信网络将在全球范围内实现语音通话和数据收集等功能。日前，为了实现全球随时随地的“星链” WiFi 互联网接入的“虹云工程”被列入了中国航天科工五大商业航天工程之一，它将搭建高度在 的总共 156 颗卫星的低轨卫星网络，目前“虹云工程”已完成首星发射入轨，并完成 Ka 波段天地通信试验。

低轨卫星通信网络的部署和研究工作如火如荼，而低轨卫星接入网协议是保证其准确可靠工作的重要基础。不同低轨卫星通信网络，也需要具备适合该网络场景的接入及切换协议才能更好工作。因此低轨卫星通信网络研究中，针对特定低轨卫星网络场景，进行接入网协议架构和接入及切换协议流程设计是必不可少的内容。

### 2.2.3. 意义

## 2.3. 实现方法

### 2.3.1. 有限状态机介绍

1. **项目难点：**
   - 将协议内容抽象成有限状态机需要细致的考虑，每一个状态设置的是否合理，是否会造成发送端和接收端的不匹配，定时器的设置；
   - 项目中使用大量指针操作，需要考虑指针越界以及内存泄漏的问题；
2. **FSM定义：**
   - 组成：
     - 状态机由有限个状态、触发事件、执行动作和状态转移组成；
   - 规则：
     - 任一时刻，状态机只能处于一种状态；
     - 状态机在某个状态下可以接受特定触发事件的触发，在成功执行相关动作后，即可转变到下一个状态，若执行动作失败则保持原状态；
     - 同一触发事件，可以使状态机从多种不同状态转变到同一种状态，但不能使系统从同一种状态转变成多种不同状态。

3. **FSM实现方法：**
   - `switch-case`条件分支语句，但是该方法耦合度较大且庞大的分支语句容易使得程序的主干被模糊。
   - 表驱动法。一种编程模式，它通过查表而不是使用逻辑语句来查找信息，具体来说，就是为状态机创建一张查找表，表里通过保存函数指针调用具体动作执行函数来完成事件的执行，并根据状态机的状态转换规则来完成状态转换；

4. **表驱动法实现状态机:**
   - 状态机数据结构
   - 表项的数据结构
   - 查表算法

    ```cpp {class=line-numbers}
    /* 状态转移表表项的数据结构定义 */
    typedef struct
    {
      ue_rrc_state current_state; /* 当前状态 */
      ue_rrc_eve_id event_id; /* 触发事件标识 */
      s32 (*eve_act_func) (void * message, u32 len); /* 对应事件的动作执行函数 */
      ue_rrc_state next_state; /* 下一状态 */
    }ue_rrc_fsm_tran_entry;

    /*状态机的数据结构定义*/
    typedef struct
    {
      ue_rrc_state current_state; /* 状态机的当前状态 */
      s32 table_size; /* 状态转移表的大小 */
      ue_rrc_fsm_tran_entry * fsm_table; /* 状态机的状态转移表 */
    }ue_rrc_fsm;

    /*
    *>>>函数说明：状态机初始化，包括设置当前状态、创建状态转移表
    *>>>参数：fsm -> 指向RRC状态机的指针的地址；init_state -> 初始状态；size -> 状态转移表的大小
    *>>>返回值：成功返回1，失败返回0
    */
    s32 ue_rrc_fsm_init(ue_rrc_fsm ** fsm, ue_rrc_state init_state, s32 size);

    /*
    *>>>函数说明：根据状态机的当前状态和触发事件进行状态转移
    *>>>参数：fsm -> 指向RRC状态机的指针；event_id -> 事件id；message -> 具体的RRC消息
    *>>>返回值：成功返回1，失败返回0
    */
    s32 ue_rrc_fsm_handle(ue_rrc_fsm * fsm, ue_rrc_eve_id event_id, void * message, u32 len)
    {
      /*1.对指针参数进行检查*/
      if (!fsm)
      {
        printf("In func FSMHandle() -> fsm is null\n");
        return 0; /* 失败返回0 */
      }

      /*2.根据状态机的当前状态和状态转移表进行相关动作和状态转移*/
      for (s32 i = 0; i < fsm->table_size; ++i)
      {
        if (event_id == fsm->fsm_table[i].event_id && fsm->current_state == fsm->fsm_table[i].current_state)
        {
          if (fsm->fsm_table[i].eve_act_func(message, len)) /* 执行事件成功 */
          {
            fsm->current_state = fsm->fsm_table[i].next_state; /* 转移到下一状态 */
            break;
          }
          else
            break; /* 事件执行失败，保持原状态 */
        }
      }
      return 1; /* 成功返回1 */
    }

    /*
    *>>>函数说明：事件检查，此处为检查事件队列是否为空
    *>>>参数：
    *>>>返回值：
    */
    s8 ue_rrc_event_check(u32 * mess_len, void ** message);
    ```

# 3. Massive MIMO相关项目介绍

# 4. 比赛介绍

# 5. 别人的面经

## 5.1. 阿里

1. 阿里
   - 三道题：简单 中等 困难
   - 翻转链表问了翻转链表的时间复杂度和空间复杂度
   - 二叉树的层序遍历：需要获得每一层的遍历结果，问了时间复杂度和空间复杂度
   - LRU缓存机制：这一道题自己写的不是很好。没有用哈希表和双向链表来做，面试官提醒了一下。本人直接用的LinkedHashmap。需要考虑map容量的影响。

2. 阿里-polardb-c++开发
   - 10w个数中取3个数，让这3个数的和的绝对值最小
   - N个数，有一个数出现次数超过N/2
   - 两个字符串的最长公共子序列，并打印出来：
   - topK问题
   - 相交链表问题
   - 宏和inline区别
   - 动态库和静态库的区别？
   - 三次握手
   - TCP具体实现

    ```cpp {class-line-numbers}
    str1 str2 
    str1 = 4234235235325325235.....(<1000) 
    str1 * str2 
    struct:求sizeof 
    char a; 
    char b; 
    double c; 
    int d;
    ```

## 5.2. 字节

1. 字节后端
   - 操作系统
     - 操作系统中用户态和内核态的区别？（呜，我说之前见过，但忘了，然后面试官说辣你记得啥，然后我说线程进程）
     - 操作系统的线程和进程的区别？
     - 线程间的通信方式有哪些？
     - 线程间的切换和进程间的切换哪个代价大？
   - 计算机网络
     - 浏览器输入域名之后发生了些什么？
     - 说一下DNS具体是怎么解析的？
     - 客户端和服务器是如何建立连接的？
     - 如果客户端在三次握手中发送第三次请求的时出现故障了，服务端会断开连接吗？
     - HTTP传输使用的是TCP协议还是UDP协议？
   - MySQL数据库
     - 数据库中有哪些引擎，之间有哪些区别？
     - B+树索引和hash树索引的区别？
   - 算法题
     - 给你一堆螺母和螺帽，每个螺母都有一个相对应的螺帽，但是他们之间的对应关系已经打乱。你可以比较螺母和螺帽的大小关系，但是你无法比较螺母和螺母的大小关系，你也无法比较螺帽和螺帽的大小关系。设计一个算法，找出螺母和螺帽的对应关系，时间复杂度为Onlogn，如nut[9] = { 5, 9, 3, 7, 1, 8, 2, 4, 6 }; bolt[9] = { 7, 4, 1, 2, 5, 6, 9, 8, 3 }; 。（快排）
     - 还是两个数组， 打印最长公共子序列的长度，如【 1、2、3、2、1 】和 【 3、2、1、4、5 】的最长公共子序列为【3、2、1】，长度为3.（动态规划
