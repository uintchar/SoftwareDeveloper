- [1. 数组](#1-数组)
  - [1.1. 二分查找](#11-二分查找)
    - [1.1.1. #704 二分查找](#111-704-二分查找)
    - [1.1.2. #35 搜索插入位置](#112-35-搜索插入位置)
    - [1.1.3. #34 在排序数组中查找元素的第一个和最后一个位置](#113-34-在排序数组中查找元素的第一个和最后一个位置)
    - [1.1.4. #69 x 的平方根](#114-69-x-的平方根)
    - [1.1.5. #367 有效的完全平方数](#115-367-有效的完全平方数)
    - [1.1.6. #33 搜索旋转排序数组](#116-33-搜索旋转排序数组)
    - [1.1.7. #81 搜索旋转排序数组 II](#117-81-搜索旋转排序数组-ii)
    - [1.1.8. #154 寻找旋转排序数组中的最小值 II](#118-154-寻找旋转排序数组中的最小值-ii)
    - [1.1.9. #540 有序数组中的单一元素](#119-540-有序数组中的单一元素)
    - [1.1.10. #4 寻找两个正序数组的中位数](#1110-4-寻找两个正序数组的中位数)
  - [1.2. 双指针](#12-双指针)
    - [1.2.1. #15 三数之和](#121-15-三数之和)
    - [1.2.2. #18 四数之和](#122-18-四数之和)
    - [1.2.3. #27 移除元素](#123-27-移除元素)
    - [1.2.4. #26 删除排序数组中的重复项](#124-26-删除排序数组中的重复项)
    - [1.2.5. #283 移动零](#125-283-移动零)
    - [1.2.6. #844 比较含退格的字符串](#126-844-比较含退格的字符串)
    - [1.2.7. #977 有序数组的平方](#127-977-有序数组的平方)
    - [1.2.8. #167 两数之和 II - 输入有序数组](#128-167-两数之和-ii---输入有序数组)
    - [1.2.9. #88 合并两个有序数组](#129-88-合并两个有序数组)
    - [1.2.10. #142 环形链表 II](#1210-142-环形链表-ii)
  - [1.3. 滑动窗口](#13-滑动窗口)
    - [1.3.1. #209 长度最小的子数组](#131-209-长度最小的子数组)
    - [1.3.2. #904 水果成篮](#132-904-水果成篮)
    - [1.3.3. #76 最小覆盖子串](#133-76-最小覆盖子串)
  - [1.4. 模拟行为](#14-模拟行为)
    - [1.4.1. #54. 螺旋矩阵](#141-54-螺旋矩阵)
    - [1.4.2. #59. 螺旋矩阵 II](#142-59-螺旋矩阵-ii)
- [2. 字符串](#2-字符串)
  - [2.1. 引言](#21-引言)
  - [2.2. 相关题目](#22-相关题目)
    - [2.2.1. #541 反转字符串II](#221-541-反转字符串ii)
    - [2.2.2. #151 翻转字符串里的单词](#222-151-翻转字符串里的单词)
    - [2.2.3. #28 实现`strStr()`](#223-28-实现strstr)
    - [2.2.4. #459 重复的子字符串](#224-459-重复的子字符串)
- [3. 链表](#3-链表)
  - [3.1. 链表的增删改查](#31-链表的增删改查)
    - [3.1.1. #203. 移除链表元素](#311-203-移除链表元素)
    - [3.1.2. #707 设计链表](#312-707-设计链表)
  - [3.2. 链表的经典题目](#32-链表的经典题目)
    - [3.2.1. #206 翻转链表（链表逆序）](#321-206-翻转链表链表逆序)
    - [3.2.2. #19 删除链表的倒数第 N 个结点](#322-19-删除链表的倒数第-n-个结点)
    - [3.2.3. #142 环形链表II](#323-142-环形链表ii)
    - [3.2.4. #21 合并两个有序链表](#324-21-合并两个有序链表)
    - [3.2.5. #24 两两交换链表中的节点](#325-24-两两交换链表中的节点)
    - [3.2.6. #160 相交链表](#326-160-相交链表)
    - [3.2.7. #234 回文链表](#327-234-回文链表)
- [4. 栈和队列](#4-栈和队列)
  - [4.1. 引言](#41-引言)
  - [4.2. 相关题目](#42-相关题目)
    - [4.2.1. #232 用栈实现队列](#421-232-用栈实现队列)
    - [4.2.2. #225 用队列实现栈](#422-225-用队列实现栈)
    - [4.2.3. ##20 有效的括号](#423-20-有效的括号)
    - [4.2.4. #1047 删除字符串中的所有相邻重复项](#424-1047-删除字符串中的所有相邻重复项)
    - [4.2.5. #150 逆波兰表达式求值](#425-150-逆波兰表达式求值)
    - [4.2.6. #239 滑动窗口最大值](#426-239-滑动窗口最大值)
    - [4.2.7. #347 前 $K$ 个高频元素](#427-347-前-k-个高频元素)
- [5. 哈希表](#5-哈希表)
  - [5.1. 引言](#51-引言)
  - [5.2. 相关题目](#52-相关题目)
    - [5.2.1. #1 两数之和](#521-1-两数之和)
    - [5.2.2. #454 四数相加 II](#522-454-四数相加-ii)
    - [5.2.3. ##128 最长连续序列](#523-128-最长连续序列)
- [6. 树](#6-树)
  - [6.1. 引言](#61-引言)
  - [6.2. 相关题目](#62-相关题目)
    - [6.2.1. #144、#94、#145 二叉树的前中后序遍历，递归方法](#621-14494145-二叉树的前中后序遍历递归方法)
    - [6.2.2. #144、#94、#145 二叉树的前中后序遍历，迭代方法](#622-14494145-二叉树的前中后序遍历迭代方法)
    - [6.2.3. #102 二叉树的层序遍历](#623-102-二叉树的层序遍历)
    - [6.2.4. #226 翻转二叉树](#624-226-翻转二叉树)
    - [6.2.5. #226 判断一棵树是否对称](#625-226-判断一棵树是否对称)
    - [6.2.6. #222 完全二叉树的节点个数](#626-222-完全二叉树的节点个数)
    - [6.2.7. #106 从后序与中序遍历序列构造二叉树](#627-106-从后序与中序遍历序列构造二叉树)
    - [6.2.8. #105 从前序与中序遍历序列构造二叉树](#628-105-从前序与中序遍历序列构造二叉树)
    - [6.2.9. #236 二叉树的最近公共祖先](#629-236-二叉树的最近公共祖先)
    - [6.2.10. #235 二叉搜索树的最近公共祖先](#6210-235-二叉搜索树的最近公共祖先)
    - [6.2.11. #701 二叉搜索树中的插入操作](#6211-701-二叉搜索树中的插入操作)
    - [6.2.12. #450 删除二叉搜索树中的节点](#6212-450-删除二叉搜索树中的节点)
    - [6.2.13. #669 修剪二叉搜索树](#6213-669-修剪二叉搜索树)
    - [6.2.14. #108 将有序数组转换为二叉搜索树](#6214-108-将有序数组转换为二叉搜索树)
    - [6.2.15. #538 把二叉搜索树转换为累加树](#6215-538-把二叉搜索树转换为累加树)
- [7. 图](#7-图)
  - [7.1. 引言](#71-引言)
  - [7.2. 相关题目](#72-相关题目)
- [8. 动态规划](#8-动态规划)
  - [8.1. 引言](#81-引言)
  - [8.2. 相关题目](#82-相关题目)
    - [8.2.1. #746 使用最小花费爬楼梯](#821-746-使用最小花费爬楼梯)
    - [8.2.2. #63 不同路径 II](#822-63-不同路径-ii)
    - [8.2.3. #96 不同的二叉搜索树](#823-96-不同的二叉搜索树)
    - [8.2.4. #343 整数拆分](#824-343-整数拆分)
    - [8.2.5. #300 最长递增子序列](#825-300-最长递增子序列)
- [9. 贪心思想](#9-贪心思想)
  - [9.1. 引言](#91-引言)
  - [9.2. 相关题目](#92-相关题目)
    - [9.2.1. #455 分发饼干](#921-455-分发饼干)
    - [9.2.2. #135 分发糖果](#922-135-分发糖果)
    - [9.2.3. #435 无重叠区间](#923-435-无重叠区间)
    - [9.2.4. #452 用最少数量的箭引爆气球](#924-452-用最少数量的箭引爆气球)
    - [9.2.5. #605 种花问题](#925-605-种花问题)
    - [9.2.6. #763 划分字母区间](#926-763-划分字母区间)
- [10. 回溯](#10-回溯)
  - [10.1. 引言](#101-引言)
  - [10.2. 相关题目](#102-相关题目)
    - [10.2.1. #77 求组合数](#1021-77-求组合数)
    - [10.2.2. #46 求全排列](#1022-46-求全排列)
- [11. 复合数据结构](#11-复合数据结构)
  - [11.1. 引言](#111-引言)
  - [11.2. 相关题目](#112-相关题目)
    - [11.2.1. #146 LRU 缓存机制](#1121-146-lru-缓存机制)
    - [11.2.2. #684 冗余连接（并查集的应用）](#1122-684-冗余连接并查集的应用)

# 1. 数组

## 1.1. 二分查找

- STL中关于二分查找的函数有三个`lower_bound、upper_bound、binary_search`。这三个函数都运用于有序区间.
  - `ForwardIter lower_bound(ForwardIter first, ForwardIter last, const _Tp &val)`算法返回一个非递减序列`[first, last)`中的第一个大于等于值val的位置；
  - `ForwardIter upper_bound(ForwardIter first, ForwardIter last, const _Tp& val)`算法返回一个非递减序列`[first, last)`中的第一个大于值val的位置；

- 相关题目：
  - #704 二分查找
  - #35 搜索插入位置
  - #34 在排序数组中查找元素的第一个和最后一个位置
  - #69 $x$ 的平方根
  - #367 有效的完全平方数
  - #33 搜索旋转排序数组
  - #81 搜索旋转排序数组 II
  - #154 寻找旋转排序数组中的最小值 II（待完成）
  - #540 有序数组中的单一元素（待完成）
  - #4 寻找两个正序数组的中位数（待完成）

### 1.1.1. #704 二分查找

```cpp {class=line-numbers}
// 左闭右闭写法
int binSearch(vector<int> &nums, int target)
{
  int l = 0, r = nums.size() - 1;
  while (l <= r)
  {
    int mid = (l + r) / 2;
    if (nums[mid] > target)
      r = mid - 1;
    else if (nums[mid] < target)
      l = mid + 1;
    else
      return mid;
  }
  return -1;
}
```

```cpp {class=line-numbers}
// 左闭右开写法
int binSearch(vector<int> &nums, int target)
{
  int l = 0, r = nums.size();
  while (left < right)
  {
    int mid = (l + r) / 2;
    if (nums[mid] > target)
      r = mid;
    else if (nums[mid] < target)
      l = mid + 1;
    else
      return mid;
  }
  return -1;
}
```

### 1.1.2. #35 搜索插入位置

给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。你可以假设数组中无重复元素。

```cpp {class=line-numbers}
// 暴力解法
int searchInsert(vector<int> &nums, int target)
{
  for (int i = 0; i < nums.size(); i++)
  {
    // 处理如下三种情况：目标值在数组所有元素之前；等于数组中某一个元素；插入数组中的位置
    if (nums[i] >= target)
      return i;
    }
  }
  // 目标值在数组所有元素之后的情况
  return nums.size();
}
```

```cpp {class=line-numbers}
// 二分法
int searchInsert(vector<int> &nums, int target)
{
  int n = nums.size();
  // 插入位置为最左边
  if (n < 1 || target < nums[0])
    return 0;

  // 插入位置在最右边
  if (target > nums[n - 1])
    return n;

  // 目标值存在数组内
  int l = 0, r = n - 1;
  while (l <= r)
  {
    int mid = (l + r) / 2;
    if (nums[mid] == target)
      return mid;
    else if (nums[mid] > target)
      r = mid - 1;
    else
      l = mid + 1;
  }

  // 插入位置为数组内部
  return r + 1;
}
```

### 1.1.3. #34 在排序数组中查找元素的第一个和最后一个位置

给定一个按照升序排列的整数数组`nums`，和一个目标值`target`。找出给定目标值在数组中的开始位置和结束位置。如果数组中不存在目标值`target`，返回`[-1, -1]`。
进阶：你可以设计并实现时间复杂度为$O(logn)$的算法解决此问题吗？

```cpp {class=line-numbers}
// 暴力解法
vector<int> searchRange(vector<int> &nums, int target)
{
  vector<int> ret = {-1, -1};
  int n = nums.size();
  if (n < 1)
    return ret;

  for (int i = 0; i < n; ++i)
  {
    if (nums[i] == target)
    {
      ret[0] = ret[1] = i;
      int j = i + 1;
      while (j < n && nums[j] == target)
        ++j;
      ret[1] = j - 1;
      break;
    }
  }

  return ret;
}
```

```cpp {class=line-numbers}
// 二分查找
vector<int> searchRange(vector<int> &nums, int target)
{
  if (nums.empty())
    return vector<int>{-1, -1};

  int lower = lower_bound(nums, target);
  int upper = upper_bound(nums, target) - 1; // 这里需要减1位

  if (lower == nums.size() || nums[lower] != target)
    return vector<int>{-1, -1};
  return vector<int>{lower, upper};
}

// 辅函数
int lower_bound(vector<int> &nums, int target)
{
  int l = 0, r = nums.size() - 1, mid;
  while (l <= r)
  {
    mid = (l + r) / 2;
    if (nums[mid] >= target)
      r = mid - 1;
    else
      l = mid + 1;
  }
  return l;
}

// 辅函数
int upper_bound(vector<int> &nums, int target)
{
  int l = 0, r = nums.size() - 1, mid;
  while (l <= r)
  {
    mid = (l + r) / 2;
    if (nums[mid] > target)
      r = mid - 1;
    else
      l = mid + 1;
  }
  return l;
}
```

### 1.1.4. #69 x 的平方根

实现`int sqrt(int x)`函数。计算并返回`x`的平方根，其中`x`是非负整数。由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。

```cpp {class=line-numbers}
// 二分查找（左闭右闭）思想
int mySqrt(int x)
{
  if (x == 0)
    return 0;

  long long l = 1, r = x, mid = 0;
  while (l <= r)
  {
    mid = (l + r) / 2;
    if (mid * mid < x)
      l = mid + 1;
    else if (mid * mid > x)
      r = mid - 1;
    else
      return mid;
  }
  return r;
}

// 牛顿迭代法？？？
```

### 1.1.5. #367 有效的完全平方数

```cpp {class=line-numbers}
bool isPerfectSquare(int num)
{
  if (num == 0)
    return true;

  long long l = 1, r = num, mid = 0;
  while (l <= r)
  {
    mid = (l + r) / 2;
    if (mid * mid > num)
      r = mid - 1;
    else if (mid * mid < num)
      l = mid + 1;
    else
      return true;
  }
  return false;
}
```

### 1.1.6. #33 搜索旋转排序数组

整数数组`nums`按升序排列，数组中的值互不相同。在传递给函数之前，`nums`在预先未知的某个下标`k（0 <= k < nums.length）`上进行了旋转，使数组变为`[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]`（下标从`0`开始计数）。给你旋转后的数组`nums`和一个整数`target`，如果`nums`中存在这个目标值`target`，则返回它的下标，否则返回`-1`。

```cpp {class=line-numbers}
int search(vector<int> &nums, int target)
{
  int n = nums.size();
  int l = 0, r = n - 1, mid = 0;

  while (l <= r)
  {
    mid = (l + r) / 2;
    if (nums[mid] == target) return mid;
    if (nums[mid] >= nums[l]) // 数组左边有序
    {
      if (nums[mid] > target && nums[l] <= target) // 目标值是否在左边有序数组内？
        r = mid - 1;
      else
        l = mid + 1;
    }
    else if (nums[mid] <= nums[r]) // 数组右边有序
    {
      if (nums[mid] < target && nums[r] >= target) // 目标值是否在右边有序数组内？
        l = mid + 1;
      else
        r = mid - 1;
    }
  }
  return -1;
}
```

### 1.1.7. #81 搜索旋转排序数组 II

相对于#33，数组中的存在重复的值

```cpp {class=line-numbers}
// 时间复杂度：O(n)，最坏情况下数组元素均相等且不为target，我们需要访问所有位置才能得出果。
// 空间复杂度：O(1)。
bool search(vector<int> &nums, int target)
{
  int n = nums.size();
  int l = 0, r = n - 1, mid = 0;

  while (l <= r)
  {
    mid = (l + r) / 2;
    if (nums[mid] == target)
      return true;

    if (nums[mid] < nums[r]) // 右区间有序
    {
      if (nums[mid] < target && nums[r] >= target)
        l = mid + 1;
      else
        r = mid - 1;
    }
    else if (nums[mid] > nums[l]) // 左区间有序
    {
      if (nums[mid] > target && nums[l] <= target)
        r = mid - 1;
      else
        l = mid + 1;
    }
    else if (nums[mid] == nums[l]) // 无法区分左区间是否有序
      ++l;
    else if (nums[mid] == nums[r]) // 无法区分右区间是否有序
      --r;
  }
  return false;
}

```

### 1.1.8. #154 寻找旋转排序数组中的最小值 II

```cpp {class=line-numbers}

```

### 1.1.9. #540 有序数组中的单一元素

```cpp {class=line-numbers}

```

### 1.1.10. #4 寻找两个正序数组的中位数

```cpp {class=line-numbers}

```

## 1.2. 双指针

- 双指针主要用于遍历数组，两个指针指向不同的元素，从而协同完成任务。也可以延伸到多个数组的多个指针。
- 若两个指针指向同一数组，遍历方向相同且不会相交，则也称为滑动窗口（两个指针包围的区域即为当前的窗口），经常用于区间搜索。
- 若两个指针指向同一数组，但是遍历方向相反，则可以用来进行搜索，待搜索的数组往往是排好序的。
- 相关题目：
  - #15 三数之和
  - #18 四数之和
  - #27 移除元素
  - #26 删除排序数组中的重复项
  - #283 移动零
  - #844 比较含退格的字符串
  - #977 有序数组的平方
  - #167 两数之和 II - 输入有序数组
  - #88 合并两个有序数组
  - #142 环形链表 II

### 1.2.1. #15 三数之和

```cpp {class=line-numbers}
// 双指针法，注意去除重复元组
vector<vector<int>> threeSum(vector<int> &nums)
{
  vector<vector<int>> ans;
  if (nums.size() < 3) return ans;

  sort(nums.begin(), nums.end());
  for (int i = 0; i < nums.size() - 2; ++i)
  {
    if (nums[i] > 0) return ans; // 排序后若首元素大于0，则不存在三数之和大于0
    if (i > 0 && nums[i] == nums[i - 1]) continue; // 去除重复的元组

    int left = i + 1, right = nums.size() - 1;
    while (left < right)
    {
      if (nums[i] + nums[left] + nums[right] < 0) ++left;
      else if (nums[i] + nums[left] + nums[right] > 0) --right;
      else
      {
        ans.push_back({nums[i], nums[left], nums[right]});
        while (left < right && nums[left + 1] == nums[left]) ++left;
        while (left < right && nums[right - 1] == nums[right]) --right;
        ++left; --right;
      }
    }
  }

  return ans;
}
```

### 1.2.2. #18 四数之和

```cpp {class=line-numbers}
vector<vector<int>> fourSum(vector<int> &nums, int target)
{
  vector<vector<int>> ans;
  if (nums.size() < 4) return ans;

  sort(nums.begin(), nums.end());
  for (int i = 0; i < nums.size() - 3; ++i)
  {
    if (i > 0 && nums[i] == nums[i - 1]) continue;

    for (int j = i + 1; j < nums.size() - 2; ++j)
    {
      if (j > i + 1 && nums[j] == nums[j - 1]) continue;

      int left = j + 1, right = nums.size() - 1;
      while (left < right)
      {
        if (nums[i] + nums[j] + nums[left] + nums[right] < target) ++left;
        else if (nums[i] + nums[j] + nums[left] + nums[right] > target) --right;
        else
        {
          ans.push_back({nums[i], nums[j], nums[left], nums[right]});
          while (left < right && nums[left + 1] == nums[left]) ++left;
          while (left < right && nums[right - 1] == nums[right]) --right;
          ++left; --right;
        }
      }
    }
  }
  return ans;
}
```

### 1.2.3. #27 移除元素

```cpp {class=line-numbers}
// 快慢指针，通过fast指针找到下一个不等于val的元素放到slow位置
int removeElement(vector<int> &nums, int val)
{
  int fast = 0, slow = 0;
  while (fast < nums.size())
  {
    if (val == nums[fast])
      fast++;
    else
      nums[slow++] = nums[fast++];
  }
  return slow;
}
```

### 1.2.4. #26 删除排序数组中的重复项

```cpp {class=line-numbers}
// 通过fast指针找到第一个不重复的元素放到slow位置
int removeDuplicates(vector<int> &nums)
{
  if (nums.size() <= 1)
    return nums.size();

  int fast = 1, slow = 1;
  while (fast < nums.size())
  {
    if (nums[fast] == nums[fast - 1])
      fast++;
    else
      nums[slow++] = nums[fast++];
  }
  return slow;
}
```

### 1.2.5. #283 移动零

```cpp {class=line-numbers}
void moveZeroes(vector<int> &nums)
{
  int fast = 0, slow = 0;
  while (fast < nums.size())
  {
    if (nums[fast] == 0)
      fast++;
    else
      nums[slow++] = nums[fast++];
  }

  for (int i = slow; i < nums.size(); ++i)
    nums[i] = 0;
}
```

### 1.2.6. #844 比较含退格的字符串

```cpp {class=line-numbers}
// 从后往前比，某个字符是否被删除掉，只与其前面的'#'有关
// string S = "bxj##tw", T = "bxo#j##tw"
bool backspaceCompare(string S, string T)
{
  int i = S.size() - 1, j = T.size() - 1;

  while (i >= 0 || j >= 0)
  {
    int delSNum = 0, delTNum = 0;

    // 找到S中第一个要比较的字符
    while (i >= 0)
    {
      if (S[i] == '#')
      {
        ++delSNum;
        --i;
      }
      else if (delSNum > 0)
      {
        --delSNum;
        --i;
      }
      else
        break;
    }

    // 找到T中第一个要比较的字符
    while (j >= 0)
    {
      if (T[j] == '#')
      {
        ++delTNum;
        --j;
      }
      else if (delTNum > 0)
      {
        --delTNum;
        --j;
      }
      else
        break;
    }

    if (i < 0 && j < 0)
      return true;
    if ((i < 0 && j >= 0) || (i >= 0 && j < 0))
      return false;

    if (S[i] != T[j])
      return false;
    else
    {
      --i;
      --j;
    }
  }
  return true;
}
```

### 1.2.7. #977 有序数组的平方

```cpp {class=line-numbers}
vector<int> sortedSquares(vector<int> &nums)
{
  vector<int> ret(nums.size(), 0);
  int pos = nums.size() - 1;
  for (int i = 0, j = nums.size() - 1; i <= j;)
  {
    if (nums[i] * nums[i] < nums[j] * nums[j])
    {
      ret[pos--] = nums[j] * nums[j];
      j--;
    }
    else
    {
      ret[pos--] = nums[i] * nums[i];
      i++;
    }
  }
  return ret;
}
```

### 1.2.8. #167 两数之和 II - 输入有序数组

```cpp {class=line-numbers}
vector<int> twoSum(vector<int> &numbers, int target)
{
  vector<int> ret(2, 0);
  int l = 0, r = numbers.size() - 1;

  while (l < r)
  {
    if (numbers[l] + numbers[r] == target)
    {
      ret[0] = l + 1;
      ret[1] = r + 1;
      return ret;
    }
    if (numbers[l] + numbers[r] < target) // 两数和小于目标值，左指针右移一位
      ++l;
    else // 两数和大于目标值，右指针左移一位
      --r;
  }
  return ret;
}
```

### 1.2.9. #88 合并两个有序数组

```cpp {class=line-numbers}
void merge(vector<int> &nums1, int m, vector<int> &nums2, int n)
{
  int p1 = m - 1, p2 = n - 1, p3 = m + n - 1;
  while (p2 >= 0)
  {
    if (p1 < 0)
    {
      for (int i = 0; i <= p2; ++i)
        nums1[i] = nums2[i];
      break;
    }

    if (nums1[p1] < nums2[p2])
      nums1[p3--] = nums2[p2--];
    else
      nums1[p3--] = nums1[p1--];
  }
}
```

### 1.2.10. #142 环形链表 II

对于链表找环路的问题，有一个通用的解法——快慢指针（Floyd判圈法）。给定两个指针，分别命名为 `slow`和`fast`，起始位置在链表的开头。每次`fast`前进两步，`slow`前进一步。如果`fast`可以走到尽头，那么说明没有环路；如果`fast`可以无限走下去，那么说明一定有环路，且一定存在一个时刻 `slow`和`fast`相遇。当`slow`和`fast`第一次相遇时，我们将`fast`重新移动到链表开头，并让`slow`和`fast`每次都前进一步。当`slow`和`fast`第二次相遇时，相遇的节点即为环路的开始点。

```cpp {class=line-numbers}
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
ListNode *detectCycle(ListNode *head)
{
  ListNode *fast = head, *slow = head;
  
  do
  {
    if (!fast || !fast->next) // fast是否可以走到尽头？
      return nullptr;
    fast = fast->next->next; // fast走两步
    slow = slow->next; // slow走一步
  } while (fast != slow); // 当fast和slow首次相遇时代表存在环路 

  fast = head;
  while (fast != slow)
  {
    fast = fast->next;
    slow = slow->next;
  }
  return fast;
}
```

## 1.3. 滑动窗口

- 相关题目
  - #209 长度最小的子数组
  - #904 水果成篮
  - #76 最小覆盖子串

### 1.3.1. #209 长度最小的子数组

```cpp {class=line-numbers}
// 暴力解法，以数组中的每个元素为起点开始
int minSubArrayLen(int target, vector<int> &nums)
{
  int minLen = nums.size() + 1;
  for (int i = 0; i < nums.size(); ++i)
  {
    int sum = 0, j = i;
    while (sum < target)
    {
      sum += nums[j++];
      if (j >= nums.size())
        break;
    }
    if (sum >= target && minLen > j - i)
      minLen = j - i;
  }

  if (minLen != nums.size() + 1)
    return minLen;
  else
    return 0;
}
```

```cpp {class=line-numbers}
// 滑动窗口解法
int minSubArrayLen(int target, vector<int> &nums)
{
  if (nums.size() == 0)
    return 0;

  int start = 0, end = 0, minLen = nums.size() + 1;
  int sum = 0;
  while (end < nums.size())
  {
    sum += nums[end];
    while (sum >= target)
    {
      minLen = min(minLen, end - start + 1);
      sum -= nums[start];
      ++start;
    }
    ++end;
  }
  return (minLen == nums.size() + 1) ? 0 : minLen;
}
```

### 1.3.2. #904 水果成篮

剥掉马甲该题本质就是求最多包含两个（k=2）不同字符的最大窗口大小。

```cpp {class=line-numbers}
int totalFruit(vector<int> &tree)
{
  unordered_map<int, int> window;
  const int k = 2;
  int start = 0, end = 0, maxLen = 0;

  while (end < tree.size())
  {
    window[tree[end]]++;
    // 当窗口内包含了多于k个不同的字符时，滑动窗口左端点直至窗口内只包含两种不同的字符
    while (window.size() > k)
    {
      window[tree[start]]--;
      if (window[tree[start]] == 0)
        window.erase(tree[start]);
      ++start;
    }
    maxLen = max(maxLen, end - start + 1);
    ++end;
  }
  return maxLen;
}
```

### 1.3.3. #76 最小覆盖子串

```cpp {class=line-numbers}
string minWindow(string S, string T)
{
  // 先统计T中的字符情况，同时need中记录了窗口内需要的字符情况
  unordered_map<char, int> need;
  for (int i = 0; i < T.size(); ++i)
    need[T[i]] = 0;
  for (int i = 0; i < T.size(); ++i)
    ++need[T[i]];

  int start = 0, end = 0, minStart = 0, minLen = S.size() + 1, needNum = T.size();
  while (end < S.size())
  {
    // 窗口内增加了一个需要的字符
    if (need.find(S[end]) != need.end())
    {
      // 将该字符所需数目减1，当该字符所需数目仍大于0时，将总的所需字符目减1
      if (--need[S[end]] >= 0)
        --needNum;

      // 若目前滑动窗口已包含T中全部字符，则尝试将l右移，在不影响结果的情况下获得最短子字符串
      while (needNum == 0)
      {
        if (minLen > end - start + 1) // 该窗口比原来满足需求的窗口小？
        {
          minLen = end - start + 1;
          minStart = start;
        }

        // 窗口端点左移可能会使得所需字符数变大
        if ((need.find(S[start]) != need.end()) && ++need[S[start]] > 0)
          ++needNum;
        ++start;
      }
    }
    ++end;
  }
  return (minLen == S.size() + 1) ? "" : S.substr(minStart, minLen);
}
```

## 1.4. 模拟行为

- 相关题目：
  - #54. 螺旋矩阵
  - #59. 螺旋矩阵 II

### 1.4.1. #54. 螺旋矩阵

```cpp {class=line-numbers}

```

### 1.4.2. #59. 螺旋矩阵 II

```cpp {class=line-numbers}

```

# 2. 字符串

## 2.1. 引言

## 2.2. 相关题目

- #344 反转字符串
- #541 反转字符串II
- #151 翻转字符串里的单词
- #28 实现`strStr()`（KMP算法）
- #459 重复的子字符串

### 2.2.1. #541 反转字符串II

```cpp {class=line-numbers}
string reverseStr(string s, int k)
{
  for (int i = 0; i < s.size(); i += 2 * k)
  {
    if (s.size() - i >= k)
      reverse(s, i, i + k - 1);
    else
      reverse(s, i, s.size() - 1);
  }
  return s;
}

void reverse(string &s, int left, int right)
{
  while (left < right)
  {
    swap(s[left], s[right]);
    ++left;
    --right;
  }
}
```

### 2.2.2. #151 翻转字符串里的单词

```cpp {class=line-numbers}
string reverseWords(string s)
{
  int n = s.size();
  int l = n - 1, r = n - 1;

  string ans;
  while (l >= 0)
  {
    // 跳过空格找到字母
    while (l >= 0 && s[l] == ' '){ --l; --r; }

    // 记录一个单词的范围：[l+1, r]
    while (l >= 0 && s[l] != ' ') --l;

    if (l != r) //代表找到一个单词
    {
      for (int i = l + 1; i <= r; ++i)
        ans.push_back(s[i]);
      ans.push_back(' ');
      r = l;
    }
  }

  // 后面会多加一个空格
  if (ans[ans.size() - 1] == ' ')
    ans.pop_back();

  return ans;
}
```

```cpp {class=line-numbers}
// 原址处理，空间复杂度为O(1)的方法
// 移除多余空格，将字符串整体反转，反转字符串内的每一个单词
string reverseWords(string s)
{
  int l = 0, r = 0, end = s.size() - 1;
  while (r < s.size() && s[r] == ' ') ++r; //去除起始的空格
  while (end >= 0 && s[end] == ' ') --end; //去除末尾空格

  while (r <= end) //使用快慢指针移除中间多余的空格
  {
    while (r <= end && s[r] != ' ') s[l++] = s[r++];
    if (r < end)
    {
      s[l++] = s[r++]; //单词之间需要保留一个空格
      while (r < s.size() && s[r] == ' ') ++r; //处理单词之间多余的空格
    }
  }
  s.resize(l);

  reverse(s.begin(), s.end()); //将字符串整体反转

  l = 0, r = 0;
  while (r < s.size())
  {
    while (r < s.size() && s[r] != ' ') ++r;
    reverse(s.begin() + l, s.begin() + r); //反转字符串中的每一个的单词
    ++r; //跳过空格
    l = r; //处理下一个单词
  }

  return s;
}
```

### 2.2.3. #28 实现`strStr()`

KMP算法思想：通过分析模式串的先验信息，使得当出现字符串不匹配时，可以只回退模式串，而不用回退源字符串。时间复杂度：$O(n+m)$，至多需要遍历两字符串一次。

```cpp {class=line-numbers}
//对模式串进行先验分析
void getPi(vector<int> &pi, const string &s)
{
  int j = 0;
  pi[0] = 0;
  for (int i = 1; i < s.size(); ++i)
  {
    while (j > 0 && s[i] != s[j]) j = pi[j - 1];
    if (s[i] == s[j]) ++j;
    pi[i] = j;
  }
}

int strStr(string haystack, string needle)
{
  int n = haystack.size(), m = needle.size();
  if (m < 1) return 0;
  if (m > n) return -1;

  vector<int> pi(m, 0);
  getPi(pi, needle);

  int j = 0;
  for (int i = 0; i < n; ++i)
  {
    while (j > 0 && haystack[i] != needle[j]) j = pi[j - 1];
    if (haystack[i] == needle[j]) ++j;
    if (j == m) return i - m + 1;
  }
  return -1;
}
```

### 2.2.4. #459 重复的子字符串

```cpp {class=line-numbers}
bool repeatedSubstringPattern(string s)
{
  int n = s.size();
  if (n == 0) return false;

  vector<int> pi(n, 0);
  pi[0] = 0;
  int j = 0;
  for (int i = 1; i < n; ++i)
  {
    while (j > 0 && s[i] != s[j]) j = pi[j - 1];
    if (s[i] == s[j]) ++j;
    pi[i] = j;
  }

  if (pi[n - 1] != 0 && n % (n - pi[n - 1]) == 0)
    return true;
  return false;
}
```

```cpp {class=line-numbers}

```

```cpp {class=line-numbers}

```

```cpp {class=line-numbers}

```

# 3. 链表

## 3.1. 链表的增删改查

- 相关题目：
  - #203. 移除链表元素
  - #707 设计链表

### 3.1.1. #203. 移除链表元素

```cpp {class=line-numbers}
// 不设置虚拟头节点需要考虑当删除的节点为头节点时的特殊情况
ListNode *removeElements(ListNode *head, int val)
{
  ListNode *cur = head, *pre = nullptr;

  while (cur)
  {
    if (cur == head && cur->val == val) // 如果待删除的节点是头节点
    {
      cur = cur->next;
      // delete head;
      head = cur;
    }
    else if (cur->val == val)
    {
      cur = cur->next;
      // delete q->next;
      pre->next = cur;
    }
    else
    {
      pre = cur;
      cur = cur->next;
    }
  }
  return head;
}
```

```cpp {class=line-numbers}
// 设置虚拟头节点
ListNode *removeElements(ListNode *head, int val)
{
  ListNode *virHead = new ListNode;
  virHead->next = head;

  ListNode *p = head, *q = virHead; // q记录着p的前驱
  while (p)
  {
    if (p->val == val)
    {
      p = p->next;
      // delete q->next;
      q->next = p;
    }
    else
    {
      q = p;
      p = p->next;
    }
  }

  head = virHead->next;
  delete virHead;
  return head;
}
```

### 3.1.2. #707 设计链表

```cpp {class=line-numbers}
class MyLinkedList
{
public:
  struct ListNode
  {
    int val;
    ListNode *next;
    ListNode(int x = 0) : val(x), next(nullptr) {}
  };

  MyLinkedList() : head(nullptr) {}

  int get(int index)
  {
    int count = 0;
    ListNode *p = head;
    while (p)
    {
      if (count == index)
        return p->val;
      count++;
      p = p->next;
    }
    return -1;
  }

  void addAtHead(int val)
  {
    ListNode *tmp = new ListNode(val);
    tmp->next = head;
    head = tmp;
  }

  void addAtTail(int val)
  {
    ListNode *tmp = new ListNode(val);
    if (!head) // 如果链表为空
      head = tmp;

    ListNode *p = head, *q = head;
    while (p)
    {
      q = p;
      p = p->next;
    }

    q->next = tmp;
  }

  void addAtIndex(int index, int val)
  {
    ListNode *tmp = new ListNode(val);

    if (index <= 0) // 插入头部
    {
      tmp->next = head;
      head = tmp;
      return;
    }

    ListNode *p = head, *q = head;
    int count = 0;
    while (p)
    {
      if (count == index)
      {
        tmp->next = p;
        q->next = tmp;
        return;
      }
      else
      {
        q = p;
        p = p->next;
        ++count;
      }
    }
    if (count == index) // 插入尾部
    {
      tmp->next = p;
      q->next = tmp;
      return;
    }
  }

  void deleteAtIndex(int index)
  {
    ListNode *p = head, *q = head;
    int count = 0;
    while (p)
    {
      if (count == index && index == 0)
      {
        p = p->next;
        head = p;
        q = head;
        return;
      }
      else if (count == index)
      {
        q->next = p->next;
        return;
      }
      else
      {
        q = p;
        p = p->next;
        ++count;
      }
    }
  }

private:
  ListNode *head;
};

/**
 * Your MyLinkedList object will be instantiated and called as such:
 * MyLinkedList* obj = new MyLinkedList();
 * int param_1 = obj->get(index);
 * obj->addAtHead(val);
 * obj->addAtTail(val);
 * obj->addAtIndex(index,val);
 * obj->deleteAtIndex(index);
 */
```

## 3.2. 链表的经典题目

- 相关题目：
  - #206 翻转链表（链表逆序）
  - #19 删除链表的倒数第 N 个结点
  - #142 环形链表II
  - #21 合并两个有序链表
  - #24 两两交换链表中的节点
  - #160 相交链表

### 3.2.1. #206 翻转链表（链表逆序）

```cpp {class=line-numbers}
// 非递归形式的写法
ListNode *reverseList(ListNode *head)
{
  ListNode *pre = nullptr, *cur = head;
  while (cur)
  {
    ListNode *tmp = cur->next;
    cur->next = pre;
    pre = cur;
    cur = tmp;
  }
  return pre;
}
```

```cpp {class=line-numbers}
// 递归形式的写法
ListNode *reverse(ListNode *pre, ListNode *cur)
{
  if (!cur) return pre;
  ListNode *tmp = cur->next;
  cur->next = pre;
  return reverse(cur, tmp);
}

ListNode *reverseList(ListNode *head)
{
  ListNode *pre = nullptr, *cur = head;
  return reverse(pre, cur);
}
```

### 3.2.2. #19 删除链表的倒数第 N 个结点

```cpp {class=line-numbers}
// 只用一遍扫描实现
ListNode *removeNthFromEnd(ListNode *head, int n)
{
  if (!head)
    return nullptr;

  ListNode *slow = head, *fast = head, *pre = nullptr;
  int cnt = n;

  // 先让快指针走n步
  while (cnt)
  {
    fast = fast->next;
    cnt--;
  }

  // 然后让慢指针和快指针同时走，当慢指针走到尽头时，慢指针的位置即为倒数第n个结点
  while (fast)
  {
    pre = slow;
    slow = slow->next;
    fast = fast->next;
  }

  if (slow == head)
    head = slow->next;
  else
    pre->next = slow->next;
  return head;
}
```

### 3.2.3. #142 环形链表II

```cpp {class=line-numbers}
// 见双指针的章节
ListNode *detectCycle(ListNode *head)
{
  ListNode *fast = head, *slow = head;
  bool isCycle = false;

  while (fast && fast->next)
  {
    fast = fast->next->next;
    slow = slow->next;
    if (fast == slow)
    {
      isCycle = true;
      break;
    }
  }

  if (!isCycle) // 链表中不存在环
    return nullptr;

  fast = head;
  while (fast != slow)
  {
    fast = fast->next;
    slow = slow->next;
  }
  return fast;
}
```

### 3.2.4. #21 合并两个有序链表

```cpp {class=line-numbers}
// 非递归形式的写法
ListNode *mergeTwoLists(ListNode *l1, ListNode *l2)
{
  ListNode *virHead = new ListNode;
  ListNode *p = virHead;

  while (l1 && l2)
  {
    if (l1->val < l2->val)
    {
      p->next = l1;
      l1 = l1->next;
    }
    else
    {
      p->next = l2;
      l2 = l2->next;
    }
    p = p->next;
  }

  p->next = l1 ? l1 : l2;
  ListNode *head = virHead->next;
  delete virHead;
  return head;
}
```

```cpp {class=line-numbers}
// 递归形式的写法
ListNode *mergeTwoLists(ListNode *l1, ListNode *l2)
{
  if (!l1) return l2;
  if (!l2) return l1;

  if (l1->val < l2->val)
  {
    l1->next = mergeTwoLists(l1->next, l2);
    return l1;
  }
  else
  {
    l2->next = mergeTwoLists(l1, l2->next);
    return l2;
  }
}
```

### 3.2.5. #24 两两交换链表中的节点

```cpp {class=line-numbers}
// 不交换节点中的内容而直接交换指针
ListNode *swapPairs(ListNode *head)
{
  if (!head || !head->next)
    return head;

  // 先处理前两个节点，获得新的头指针
  ListNode *tmp = head->next;
  head->next = head->next->next;
  tmp->next = head;
  head = tmp;

  // 处理后续节点
  ListNode *cur = head->next->next, *pre = head->next;
  while (cur && cur->next)
  {
    ListNode *tmp2 = cur->next->next;
    pre->next = cur->next;
    cur->next->next = cur;
    cur->next = tmp2;
    pre = cur;
    cur = tmp2;
  }
  return head;
}
```

### 3.2.6. #160 相交链表

- 假设链表 A 的头节点到相交点的距离是 a，链表 B 的头节点到相交点的距离是 b，相交点到链表终点的距离为 c。我们使用两个指针，分别指向两个链表的头节点，并以相同的速度前进，若到达链表结尾，则移动到另一条链表的头节点继续前进。按照这种前进方法，两个指针会在a + b + c 次前进后同时到达相交节点。
- 若两个链表无相交的节点，则虽然A和B两个链表长度可能不同，但是A+B和B+A的长度是相同的，所以遍历A+B和遍历B+A一定是同时结束。

```cpp {class=line-numbers}
ListNode *getIntersectionNode(ListNode *headA, ListNode *headB)
{
  ListNode *p1 = headA, *p2 = headB;

  while (p1 != p2)
  {
    p1 = (p1 ? p1->next : headB);
    p2 = (p2 ? p2->next : headA);
  }
  return p1;
}
```

### 3.2.7. #234 回文链表

```cpp {class=line-numbers}
// 方法1：空间换时间，将链表中的值复制到数组中，然后使用双指针判断回文
bool isPalindrome(ListNode *head)
{
  if (!head || !head->next)
    return true;

  ListNode *p = head;
  vector<int> arr;
  while (p)
  {
    arr.push_back(p->val);
    p = p->next;
  }

  int left = 0, right = arr.size() - 1;
  while (left <= right)
  {
    if (arr[left++] != arr[right--])
      return false;
  }
  return true;
}
```

```cpp {class=line-numbers}
// 方法2：空间复杂度O(1)，快慢指针
步骤1：找到前半部分链表的尾节点。
步骤2：反转后半部分链表。
步骤3：判断是否回文。
步骤4：恢复链表。
步骤5：返回结果。

步骤1：
可以计算链表节点的数量，然后遍历链表找到前半部分的尾节点。
可以使用快慢指针在一次遍历中找到：慢指针一次走一步，快指针一次走两步，快慢指针同时出发。当
快指针移动到链表的末尾时，慢指针恰好到链表的中间。通过慢指针将链表分为两部分。
若链表有奇数个节点，则中间的节点应该看作是前半部分。

步骤2可以使用「206. 反转链表」问题中的解决方法来反转链表的后半部分。

步骤3比较两个部分的值，当后半部分到达末尾则比较完成，可以忽略计数情况中的中间节点。

步骤4与步骤2使用的函数相同，再反转一次恢复链表本身。

```

```cpp {class=line-numbers}

```

```cpp {class=line-numbers}

```

# 4. 栈和队列

## 4.1. 引言

## 4.2. 相关题目

- 相关题目：
  - #232 用栈实现队列
  - #225 用队列实现栈
  - #20 有效的括号
  - #1047 删除字符串中的所有相邻重复项
  - #150 逆波兰表达式求值
  - #239 滑动窗口最大值
  - #347 前 $K$ 个高频元素

### 4.2.1. #232 用栈实现队列

```cpp {class=line-numbers}
// 使用两个栈实现队列，其中一个输入栈，一个输出栈
// 当进行入队列时，直接压入输入栈；
// 当进行出队列时，先判断输出栈是否为空，若为空则将输入栈的内容按顺序放入输出栈再进行出操作；
class MyQueue
{
public:
  /** Initialize your data structure here. */
  stack<int> stIn, stOut;

  MyQueue() {}

  /** Push element x to the back of queue. */
  void push(int x)
  {
    stIn.push(x);
  }

  /** Removes the element from in front of queue and returns that element. */
  int pop()
  {
    if (stOut.empty())
    {
      while (!stIn.empty())
      {
        stOut.push(stIn.top());
        stIn.pop();
      }
    }
    int ret = stOut.top();
    stOut.pop();
    return ret;
  }

  /** Get the front element. */
  int peek()
  {
    int ret = this->pop();
    stOut.push(ret);
    return ret;
  }

  /** Returns whether the queue is empty. */
  bool empty()
  {
    return stIn.empty() && stOut.empty();
  }
};
```

### 4.2.2. #225 用队列实现栈

```cpp {class=line-numbers}
class MyStack
{
public:
  /** Initialize your data structure here. */

  queue<int> que;

  MyStack() {}

  /** Push element x onto stack. */
  void push(int x)
  {
    que.push(x);
  }

  /** Removes the element on top of the stack and returns that element. */
  int pop()
  {
    int size = que.size();
    while (--size)
    {
      que.push(que.front());
      que.pop();
    }
    int ret = que.front();
    que.pop();
    return ret;
  }

  /** Get the top element. */
  int top()
  {
    return que.back();
  }

  /** Returns whether the stack is empty. */
  bool empty()
  {
    return que.empty();
  }
};
```

### 4.2.3. ##20 有效的括号

```cpp {class=line-numbers}
bool isValid(string s) 
{
  stack<char> st;
  for (char ch : s)
  {
    if (ch == '(') st.push(')');
    else if (ch == '{') st.push('}');
    else if (ch == '[') st.push(']');
    else if (st.empty() || st.top() != ch) 
      return false; //字符串有多余的右括号或当前右括号与左括号不匹配
    else st.pop();
  }
  return st.empty(); //字符串有多余左括号时栈不为空返回false
}
```

### 4.2.4. #1047 删除字符串中的所有相邻重复项

```cpp {class=line-numbers}
// 注意这里是成对消除
string removeDuplicates(string s)
{
  if (s.size() <= 1) return s;

  string ans;
  for (char ch : s)
  {
    if (ans.empty() || ans.back() != ch)
      ans.push_back(ch);
    else
      ans.pop_back();
  }
  return ans;
}

// 原址方法
string removeDuplicates(string s)
{
  if (s.size() <= 1)
    return s;

  int top = -1;
  for (int i = 0; i < s.size(); ++i)
  {
    if (top == -1 || s[top] != s[i])
      s[++top] = s[i];
    else
      --top;
  }
  s.resize(top + 1);
  return s;
}
```

### 4.2.5. #150 逆波兰表达式求值

- 逆波兰表达式（后缀表达式）严格遵循「从左到右」的运算。计算逆波兰表达式的值时，使用一个栈存储操作数，从左到右遍历逆波兰表达式，进行如下操作：
  - 如果遇到操作数，则将操作数入栈；
  - 如果遇到运算符，则将两个操作数出栈，其中先出栈的是右操作数，后出栈的是左操作数，使用运算符对两个操作数进行运算，将运算得到的新操作数入栈。
  - 整个逆波兰表达式遍历完毕之后，栈内只有一个元素，该元素即为逆波兰表达式的值。

```cpp {class=line-numbers}
int evalRPN(vector<string> &tokens)
{
  stack<int> st;

  for (auto ch : tokens)
  {
    if (ch == "+" || ch == "-" || ch == "*" || ch == "/")
    {
      int rNum = st.top(); st.pop();
      int lNum = st.top(); st.pop();

      if (ch == "+") st.push(lNum + rNum);
      else if (ch == "-") st.push(lNum - rNum);
      else if (ch == "*") st.push(lNum * rNum);
      else if (ch == "/") st.push(lNum / rNum);
    }
    else
      st.push(stoi(ch));
  }

  return st.top();
}
```

### 4.2.6. #239 滑动窗口最大值

```cpp {class=line-numbers}
// 借助单调队列实现O(N)时间复杂度，保证nums中的元素最多被push和pop一次
class Solution
{
public:
  vector<int> maxSlidingWindow(vector<int> &nums, int k)
  {
    vector<int> ans;
    MyQueue que;
    for (int i = 0; i < k; ++i)
      que.push(nums[i]);
    ans.push_back(que.front());

    for (int i = k; i < nums.size(); ++i)
    {
      que.pop(nums[i - k]);
      que.push(nums[i]);
      ans.push_back(que.front());
    }
    return ans;
  }

private:
  // 单调队列的实现，保证队列从队首到队尾为单调递减顺序
  // 队首元素为当前窗口内的最大值
  class MyQueue
  {
  public:
    deque<int> dque;

    // 用于将当前滑动窗口中的结束值入队列，入队时要保持队列的单调性质
    // 元素入队时若其前序入队元素小于入队元素，则将前序元素出队
    void push(int x)
    {
      while (!dque.empty() && x > dque.back())
        dque.pop_back();
      dque.push_back(x);
    }

    // 用于将上一滑动窗口中的起始值出队列，出队时需判断该起始值是否在该队列中
    void pop(int x)
    {
      if (!dque.empty() && x == dque.front())
        dque.pop_front();
    }

    int front()
    {
      return dque.front();
    }
  };
};
```

### 4.2.7. #347 前 $K$ 个高频元素

```cpp {class=line-numbers}
// 使用map统计频率。将map转换为vector，对vector进行自定义排序
vector<int> topKFrequent(vector<int> &nums, int k)
{
  unordered_map<int, int> count; //统计nums中各个数的出现频率
  for (auto num : nums)
    ++count[num];

  vector<pair<int, int>> tmp(count.begin(), count.end());
  sort(tmp.begin(), tmp.end(),
    [](pair<int, int> &lhs, pair<int, int> &rhs)
    { return lhs.second > rhs.second; });

  vector<int> ans;
  for (int i = 0; i < k; ++i)
    ans.push_back(tmp[i].first);
  return ans;
}
```

```cpp {class=line-numbers}
// 使用map统计频率，利用优先级队列（小顶堆）来维护当前遍历后的k个元素，
// 当遍历完毕，优先队列里剩余的k个元素即为前k个高频元素
class cmp
{
public:
  bool operator()(pair<int, int> &lhs, pair<int, int> &rhs)
  {
    return lhs.second > rhs.second;
  }
};

vector<int> topKFrequent(vector<int> &nums, int k)
{
  unordered_map<int, int> count; //统计nums中各个数的出现频率
  for (auto num : nums)
    ++count[num];

  priority_queue<pair<int, int>, vector<pair<int, int>>, cmp> pque;
  for (auto it = count.begin(); it != count.end(); ++it)
  {
    if (pque.size() < k) //当堆中元素小于k个时，需要继续插入元素
      pque.push(*it);
    else //当堆中元素等于k个时，若当前元素频率小于堆顶元素则不必入堆
    {
      if ((*it).second > pque.top().second)
      {
        pque.pop();
        pque.push(*it);
      }
    }
  }

  vector<int> ans(k, 0);
  for (int i = k - 1; i >= 0; --i)
  {
    ans[i] = pque.top().first;
    pque.pop();
  }
  return ans;
}
```

```cpp {class=line-numbers}

```

```cpp {class=line-numbers}

```

# 5. 哈希表

## 5.1. 引言

- STL中的哈希表

## 5.2. 相关题目

- 相关题目：
  - #242 有效的字母异位词；
  - #349 两个数组的交集；
  - #202 快乐数
  - #1 两数之和(#170 两数之和 III - 数据结构设计；#653 两数之和 IV - 输入 BST)
  - #454 四数相加 II
  - #128 最长连续序列

### 5.2.1. #1 两数之和

```cpp {class=line-numbers}
// 借助哈希表可以只用一次遍历就能解题，哈希表用于记录已经访问过的元素的下标
vector<int> twoSum(vector<int> &nums, int target)
{
  unordered_map<int, int> m;
  for (int i = 0; i < nums.size(); ++i)
  {
    int t = target - nums[i];
    // if (m.count(t))
    if (m.find(t) != m.end())
      return vector<int>{m[t], i};
    m[nums[i]] = i;
  }
  return {};
}
```

### 5.2.2. #454 四数相加 II

```cpp {class=line-numbers}
int fourSumCount(vector<int> &nums1, vector<int> &nums2, vector<int> &nums3, vector<int> &nums4)
{
  unordered_map<int, int> um;

  for (auto a : nums1)
    for (auto b : nums2)
      um[a + b]++; // 初始化时为0？？？

  int count = 0;
  for (auto c : nums3)
    for (auto d : nums4)
    {
      if (um.find(0 - c - d) != um.end())
        count += um[0 - c - d];
    }
  return count;
}
```

### 5.2.3. ##128 最长连续序列

```cpp {class=line-numbers}
// 排序加双指针
int longestConsecutive(vector<int> &nums)
{
  int n = nums.size();
  if (n <= 1) return n;

  sort(nums.begin(), nums.end()); //先进行排序
  int l = 0, r = 0, maxLen = 0;
  while (r < n)
  {
    int count = 0; //统计一段连续序列中重复元素的数量
    while (r < n - 1 && nums[r + 1] == nums[r] + 1)
    {
      ++r;
      while (r < n - 1 && nums[r + 1] == nums[r]) //去除重复元素
      { ++count; ++r; }
    }
    maxLen = max(maxLen, r - l - count + 1);
    ++r; l = r;
  }
  return maxLen;
}
```

```cpp {class=line-numbers}
// 哈希表辅助实现O(N)时间复杂度
int longestConsecutive(vector<int>& nums)
{
  unordered_set<int> hSet;
  for (auto num : nums)
    hSet.insert(num);
  
  int maxLen = 0;
  while (!hSet.empty())
  {
    int cur = *(hSet.begin());
    hSet.erase(cur);
    int pre = cur - 1, next = cur + 1;
    while (hSet.count(pre)) { hSet.erase(pre); --pre; }
    while (hSet.count(next)) { hSet.erase(pre); ++next; }
    maxLen = max(maxLen, next - pre - 1);
  }
  return maxLen;
}
```

```cpp {class=line-numbers}

```

```cpp {class=line-numbers}

```

```cpp {class=line-numbers}

```

```cpp {class=line-numbers}

```

# 6. 树

## 6.1. 引言

## 6.2. 相关题目

- #144、#94、#145 二叉树的前中后序遍历，递归方法；
- #144、#94、#145 二叉树的前中后序遍历，迭代方法；
- #102 二叉树的层序遍历
- #107 二叉树的层次遍历II；
- #199 二叉树的右视图；
- #637 二叉树的层平均值；
- #429 N叉树的前序遍历；
- #515 在每个树行中找最大值；
- #117.填充每个节点的下一个右侧节点指针II
- #226 翻转二叉树
- #104 二叉树的最大深度
- #559 N叉树的最大深度
- #222 完全二叉树的节点个数
- #106 从中序与后序遍历序列构造二叉树
- #105 从前序与中序遍历序列构造二叉树
- #236 二叉树的最近公共祖先
- #235 二叉搜索树的最近公共祖先
- #701 二叉搜索树中的插入操作
- #450 删除二叉搜索树中的节点
- #669 修剪二叉搜索树
- #108 将有序数组转换为二叉搜索树
- #538 把二叉搜索树转换为累加树

### 6.2.1. #144、#94、#145 二叉树的前中后序遍历，递归方法

```cpp {class=line-numbers}
// 前序遍历
void preTra(TreeNode *root, vector<int> &ans)
{
  if (!root)
    return;

  seq.push_back(root->val);
  preTra(root->left, ans);
  preTra(root->right, ans);
}

// 中序遍历
void inTra(TreeNode *root, vector<int> &ans)
{
  if (!root)
    return;

  inTra(root->left, ans);
  ans.push_back(root->val);
  inTra(root->right, ans);
}

// 后序遍历
void posTra(TreeNode *root, vector<int> &ans)
{
  if (!root)
    return;

  posTra(root->left, ans);
  posTra(root->right, ans);
  ans.push_back(root->val);
}

vector<int> treeTraversal(TreeNode *root)
{
  vector<int> ans;
  preTra(root, ans);
  // inTra(root, ans);
  // posTra(root, ans);
  return ans;
}
```

### 6.2.2. #144、#94、#145 二叉树的前中后序遍历，迭代方法

```cpp {class=line-numbers}
// 先序遍历
vector<int> preorderTraversal(TreeNode *root)
{
  vector<int> ans;
  if (!root) return ans;

  stack<TreeNode *> st;
  st.push(root);
  while (!st.empty())
  {
    TreeNode *tmp = st.top();
    st.pop();
    ans.push_back(tmp->val);
    if (tmp->right) st.push(tmp->right);
    if (tmp->left) st.push(tmp->left);
  }

  return ans;
}

// 中序遍历
vector<int> inorderTraversal(TreeNode *root)
{
  vector<int> ans;
  if (!root) return ans;

  stack<TreeNode *> st;
  st.push(root);
  TreeNode *tmp = root;
  while (!st.empty())
  {
    while (tmp && tmp->left) // 向左找到最左边的节点
    {
      st.push(tmp->left);
      tmp = tmp->left;
    }

    TreeNode *tmp2 = st.top();
    st.pop();
    ans.push_back(tmp2->val);

    if (!tmp2->right) // 如果当前处理的节点没有右孩子，准备出栈下一个节点
      tmp = nullptr;
    else // 如果当前处理的节点有右孩子，从该右孩子开始找最左边的节点
    {
      st.push(tmp2->right);
      tmp = tmp2->right;
    }
  }
  return ans;
}

// 后序遍历：先序为“根左右”，可稍微调整为“根右左”，再逆序为“左右根”
vector<int> postorderTraversal(TreeNode *root)
{
  vector<int> ans;
  if (!root)
    return ans;

  stack<TreeNode *> st;
  st.push(root);
  while (!st.empty())
  {
    TreeNode *tmp = st.top();
    st.pop();
    ans.push_back(tmp->val);
    if (tmp->left) st.push(tmp->left);
    if (tmp->right) st.push(tmp->right);
  }
  reverse(ans.begin(), ans.end());

  return ans;
}
```

### 6.2.3. #102 二叉树的层序遍历

```cpp {class=line-numbers}
vector<vector<int>> levelOrder(TreeNode *root)
{
  vector<vector<int>> ans;
  if (!root)
    return ans;

  queue<TreeNode *> q;
  q.push(root);
  while (!q.empty())
  {
    int size = q.size();
    vector<int> tmp(size, 0);
    for (int i = 0; i < size; ++i)
    {
      TreeNode *cur = q.front();
      q.pop();
      tmp[i] = cur->val;
      if (cur->left)
        q.push(cur->left);
      if (cur->right)
        q.push(cur->right);
    }
    ans.push_back(tmp);
  }

  return ans;
}
```

### 6.2.4. #226 翻转二叉树

```cpp {class=line-numbers}
TreeNode *invertTree(TreeNode *root)
{
  if (!root)
    return root;

  swap(root->left, root->right);
  invertTree(root->left);
  invertTree(root->right);
  return root;
}
```

### 6.2.5. #226 判断一棵树是否对称

```cpp {class=line-numbers}
// 递归写法
// 判断两棵树是否对称
bool compare(TreeNode *left, TreeNode *right)
{
  if (!left && !right)
    return true;
  if ((!left && right) || (left && !right))
    return false;
  if (left->val != right->val)
    return false;

  bool lflag = compare(left->left, right->right); //左树的左子树应该和右树的右子树对称
  bool rflag = compare(left->right, right->left); //左树的右子树应该和右树的左子树对称
  return lflag && rflag;
}

bool isSymmetric(TreeNode *root)
{
  if (!root)
    return true;
  return compare(root->left, root->right);
}
```

```cpp {class=line-numbers}
// 队列辅助迭代法
bool isSymmetric(TreeNode *root)
{
  if (!root)
    return true;
  //return compare(root->left, root->right);
  queue<TreeNode *> q;
  q.push(root->left);
  q.push(root->right);
  while (!q.empty())
  {
    TreeNode *l = q.front();
    q.pop();
    TreeNode *r = q.front();
    q.pop();

    if (!l && !r)
      continue;
    if ((!l && r) || (l && !r))
      return false;
    if (l->val != r->val)
      return false;

    q.push(l->left);
    q.push(r->right);
    q.push(l->right);
    q.push(r->left);
  }
  return true;
}
```

### 6.2.6. #222 完全二叉树的节点个数

```cpp {class=line-numbers}
// 直接遍历与利用完全二叉树的性质
int countNodes(TreeNode *root)
{
  if (!root) return 0;
  
  // return 1 + countNodes(root->left) + countNodes(root->right);

  TreeNode *l = root->left, *r = root->right;
  int lh = 0, rh = 0;

  while (l) { ++lh; l = l->left; }
  while (r) { ++rh; r = r->right; }
  if (lh == rh) return (2 << lh) - 1;

  return 1 + countNodes(root->left) + countNodes(root->right);
}
```

### 6.2.7. #106 从后序与中序遍历序列构造二叉树

```cpp {class=line-numbers}
// 通过后序遍历序列和中序遍历序列构建二叉树
TreeNode *traversal(vector<int> &inorder, int ibegin, int iend, vector<int> &postorder, int pbegin, int pend)
{
  // 先通过后序序列的最后一个值确定当前子树的根节点
  TreeNode *root = new TreeNode(postorder[pend]);
  if (ibegin == iend) return root;

  // 再通过中序序列确定当前根节点的左子树节点和右子树节点
  int index = 0;
  for (int i = ibegin; i <= iend; ++i)
    if (inorder[i] == postorder[pend])
    {
      index = i;
      break;
    }

  // 递归构建左子树
  if (index - 1 >= ibegin)
  {
    int libegin = ibegin, liend = index - 1;
    int lpbegin = pbegin, lpend = pbegin + (liend - libegin);
    root->left = traversal(inorder, libegin, liend, postorder, lpbegin, lpend);
  }

  // 递归构建右子树
  if (index + 1 <= iend)
  {
    int ribegin = index + 1, riend = iend;
    int rpbegin = pbegin + (index - ibegin), rpend = pend - 1;
    root->right = traversal(inorder, ribegin, riend, postorder, rpbegin, rpend);
  }

  return root;
}

TreeNode *buildTree(vector<int> &inorder, vector<int> &postorder)
{
  int ibegin = 0, iend = inorder.size() - 1;
  int pbegin = 0, pend = postorder.size() - 1;
  if (ibegin > iend || pbegin > pend) return nullptr;

  return traversal(inorder, ibegin, iend, postorder, pbegin, pend);
}
```

### 6.2.8. #105 从前序与中序遍历序列构造二叉树

```cpp {class=line-numbers}
// 思路和 #106 一样：
// 先通过先序序列的第一个值确定根节点；
// 然后通过中序序列获得当前根节点的左子树和右子树；
```

### 6.2.9. #236 二叉树的最近公共祖先

```cpp {class=line-numbers}

```

### 6.2.10. #235 二叉搜索树的最近公共祖先

**解题思路：**

- 对于二叉树的公共祖先问题，解决思路为利用回溯从底向上搜索，遇到一个节点的左子树里有p，右子树里有q，那么当前节点就是最近公共祖先。

- 对于二叉搜索树，可以利用其有序的特点：从上往下搜索，如果找到一个满足当前节点值在给定两个节点值之间的节点则该节点为其最近公共祖先。

```cpp {class=line-numbers}
TreeNode *lowestCommonAncestor(TreeNode *root, TreeNode *p, TreeNode *q)
{
  if (!root) return root;

  if (root->val > p->val && root->val > q->val)
    return lowestCommonAncestor(root->left, p, q);
  else if (root->val < p->val && root->val < q->val)
    return lowestCommonAncestor(root->right, p, q);
  else
    return root;
}
```

### 6.2.11. #701 二叉搜索树中的插入操作

```cpp {class=line-numbers}
// 递归方式
TreeNode *insertIntoBST(TreeNode *root, int val)
{
  if (!root)
  {
    root = new TreeNode(val);
    return root;
  }
  if (root->val > val)
    root->left = insertIntoBST(root->left, val);
  else
    root->right = insertIntoBST(root->right, val);
  return root;
}

// 迭代方式
TreeNode *insertIntoBST(TreeNode *root, int val)
{
  if (!root)
  {
    root = new TreeNode(val);
    return root;
  }

  TreeNode *cur = root, *p = nullptr;
  while (cur)
  {
    p = cur;
    if (cur->val > val) cur = cur->left;
    else cur = cur->right;
  }
  if (p->val > val) p->left = new TreeNode(val);
  else p->right = new TreeNode(val);
  
  return root;
}
```

### 6.2.12. #450 删除二叉搜索树中的节点

```cpp {class=line-numbers}
// 合并两棵分别以节点l和节点r为根节点的树，保持其二叉搜索树的性质
TreeNode *combineTrees(TreeNode *l, TreeNode *r)
{
  if (!l) return r;
  if (!r) return l;

  TreeNode *tmp = l->right, *p = l;
  while (tmp)
  {
    p = tmp;
    tmp = tmp->right;
  }
  p->right = r;
  return l;
}

TreeNode *deleteNode(TreeNode *root, int key)
{
  if (!root) return root;

  TreeNode *cur = root, *p = nullptr;
  while (cur && cur->val != key)
  {
    p = cur;
    if (cur->val > key)
      cur = cur->left;
    else
      cur = cur->right;
  }

  if (!cur) return root; // 没找到要删除的节点

  if (cur == root) // 要删除的节点为根节点
  {
    return combineTrees(cur->left, cur->right);
  }
  else
  {
    if (p->left == cur)
    {
      p->left = combineTrees(cur->left, cur->right);
      return root;
    }
    else
    {
      p->right = combineTrees(cur->left, cur->right);
      return root;
    }
  }
}
```

### 6.2.13. #669 修剪二叉搜索树

```cpp {class=line-numbers}
// 递归法
TreeNode *trimBST(TreeNode *root, int low, int high)
{
  if (!root) return root;
  if (root->val < low) return trimBST(root->right, low, high);
  if (root->val > high) return trimBST(root->left, low, high);

  root->left = trimBST(root->left, low, high);
  root->right = trimBST(root->right, low, high);
  return root;
}

// 迭代法
TreeNode *trimBST(TreeNode *root, int low, int high)
{
  if (!root) return root;

  while (root && (root->val < low || root->val > high))
  {
    if (root->val < low) root = root->right;
    else root = root->left;
  }

  TreeNode *cur = root;
  while (cur)
  {
    while (cur->left && cur->left->val < low)
      cur->left = cur->left->right;
    cur = cur->left;
  }

  cur = root;
  while (cur)
  {
    while (cur->right && cur->right->val > high)
      cur->right = cur->right->left;
    cur = cur->right;
  }

  return root;
}
```

### 6.2.14. #108 将有序数组转换为二叉搜索树

```cpp {class=line-numbers}
TreeNode *traversal(vector<int> &nums, int l, int r)
{
  if (l > r)
    return nullptr;
  int m = (l + r) / 2;
  TreeNode *node = new TreeNode(nums[m]);
  node->left = traversal(nums, l, m - 1);
  node->right = traversal(nums, m + 1, r);
  return node;
}

TreeNode *sortedArrayToBST(vector<int> &nums)
{
  return traversal(nums, 0, nums.size() - 1);
}
```

### 6.2.15. #538 把二叉搜索树转换为累加树

```cpp {class=line-numbers}
void traversal(TreeNode *cur, int &preVal)
{
  if (!cur) return;
  traversal(cur->right, preVal);
  cur->val += preVal;
  preVal = cur->val;
  traversal(cur->left, preVal);
}

TreeNode *convertBST(TreeNode *root)
{
  int preVal = 0;
  traversal(root, preVal);
  return root;
}
```

```cpp {class=line-numbers}

```

```cpp {class=line-numbers}

```

```cpp {class=line-numbers}

```

# 7. 图

## 7.1. 引言

## 7.2. 相关题目

```cpp {class=line-numbers}

```

```cpp {class=line-numbers}

```

```cpp {class=line-numbers}

```

# 8. 动态规划

## 8.1. 引言

## 8.2. 相关题目

### 8.2.1. #746 使用最小花费爬楼梯

```cpp {class=line-numbers}
int minCostClimbingStairs(vector<int> &cost)
{
  int dp0 = cost[0], dp1 = cost[1];
  for (int i = 2; i < cost.size(); ++i)
  {
    int dpi = min(dp0, dp1) + cost[i]; // dpi表示到达阶梯i所需要的花费
    dp0 = dp1;
    dp1 = dpi;
  }

  return min(dp0, dp1); // 可以从最后的两个阶梯到达楼顶，且到达楼顶不需要花费体力值
}
```

### 8.2.2. #63 不同路径 II

```cpp {class=line-numbers}
int uniquePathsWithObstacles(vector<vector<int>> &obstacleGrid)
{
  int m = obstacleGrid.size();
  int n = obstacleGrid[0].size();
  vector<vector<int>> dp(m, vector<int>(n, 0));

  for (int i = 0; i < m && obstacleGrid[i][0] == 0; ++i) dp[i][0] = 1;
  for (int j = 0; j < n && obstacleGrid[0][j] == 0; ++j) dp[0][j] = 1;

  for (int i = 1; i < m; ++i)
    for (int j = 1; j < n; ++j)
    {
      if (obstacleGrid[i][j] == 1) continue;
      dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
    }

  return dp[m - 1][n - 1];
}
```

### 8.2.3. #96 不同的二叉搜索树

```cpp {class=line-numbers}
int numTrees(int n)
{
  if (n <= 2) return n;

  vector<int> dp(n + 1, 0);
  dp[0] = 1;
  dp[1] = 1;
  dp[2] = 2;
  
  // 以j为根节点的BST数目，其左子树的节点数为j - 1，右子树的节点数为i - j
  for (int i = 3; i <= n; ++i)
    for (int j = 1; j <= i; ++j)      
      dp[i] += dp[j - 1] * dp[i - j];

  return dp[n];
}
```

### 8.2.4. #343 整数拆分

当 $n \ge 2$ 时，$n$ 可以拆分成至少两个正整数的和。令 $k$ 是拆分出的第一个正整数，则剩下的部分是 $n - k$，其可以不继续拆分，或者继续拆分成至少两个正整数的和。

```cpp {class=line-numbers}
int integerBreak(int n)
{
  vector<int> dp(n + 1, 0);
  dp[2] = 1;

  for (int i = 3; i <= n; ++i)
    for (int j = 1; j < i; ++j)
      dp[i] = max(dp[i], max(j * (i - j), j * dp[i - j]));

  return dp[n];
}
```

```cpp {class=line-numbers}

```

```cpp {class=line-numbers}

```

```cpp {class=line-numbers}

```

```cpp {class=line-numbers}

```

### 8.2.5. #300 最长递增子序列

给你一个整数数组`nums`，找到其中最长严格递增子序列的长度。子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。

```cpp {class=line-numbers}
// 动态规划解法
// 定义dp[i]为考虑前i个元素，以第i个数字结尾的最长上升子序列的长度，注意nums[i]必须被选取。
int lengthOfLIS(vector<int> &nums)
{
  int n = (int)nums.size();
  if (n == 0)
    return 0;

  vector<int> dp(n, 0);
  for (int i = 0; i < n; ++i)
  {
    dp[i] = 1;
    for (int j = 0; j < i; ++j)
    {
      if (nums[j] < nums[i])
        dp[i] = max(dp[i], dp[j] + 1);
    }
  }
  return *max_element(dp.begin(), dp.end());
}
```

```cpp {class=line-numbers}
// 贪心 + 二分查找
int lengthOfLIS(vector<int> &nums)
{
  int len = 1, n = (int)nums.size();
  if (n == 0)
    return 0;

  vector<int> d(n + 1, 0);
  d[len] = nums[0];
  for (int i = 1; i < n; ++i)
  {
    if (nums[i] > d[len])
      d[++len] = nums[i];
    else
    {
      int l = 1, r = len, pos = 0; // 如果找不到说明所有的数都比nums[i]大，此时要更新d[1]，所以这里将pos设为0
      while (l <= r)
      {
        int mid = (l + r) >> 1;
        if (d[mid] < nums[i])
        {
          pos = mid;
          l = mid + 1;
        }
        else
          r = mid - 1;
      }
      d[pos + 1] = nums[i];
    }
  }
  return len;
}
```

# 9. 贪心思想

## 9.1. 引言

## 9.2. 相关题目

### 9.2.1. #455 分发饼干

```cpp {class=line-numbers}

```

### 9.2.2. #135 分发糖果

```cpp {class=line-numbers}

```

### 9.2.3. #435 无重叠区间

```cpp {class=line-numbers}

```

### 9.2.4. #452 用最少数量的箭引爆气球

```cpp {class=line-numbers}
int findMinArrowShots(vector<vector<int>> &points)
{
  // 和435题思路相同，可转换为求解最大不重叠区间的个数，不过这里区间端点相同也算重叠
  int n = points.size();
  if (n <= 1)
    return n;

  sort(points.begin(), points.end(), [](vector<int> &a, vector<int> &b) { return a[1] < b[1]; });

  int pre = points[0][1], total = 1;

  for (int i = 1; i < n; ++i)
  {
    if (points[i][0] > pre)
    {
      ++total;
      pre = points[i][1];
    }
  }
  return total;
}
```

### 9.2.5. #605 种花问题

```cpp {class=line-numbers}

```

### 9.2.6. #763 划分字母区间

题目描述：字符串`S`由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。返回一个表示每个字符串片段的长度的列表。

```cpp {class=line-numbers}

```

# 10. 回溯

## 10.1. 引言

## 10.2. 相关题目

### 10.2.1. #77 求组合数

```cpp {class=line-numbers}
void backtracking(vector<vector<int>> &ans, vector<int> path, int n, int k, int count)
{
  if (path.size() == k)
  {
    ans.push_back(path);
    return;
  }

  for (int i = count; (n - i + 1) >= (k - path.size()); ++i)
  {
    path.push_back(i);
    backtracking(ans, path, n, k, i + 1);
    path.pop_back();
  }
}
vector<vector<int>> combine(int n, int k)
{
  vector<vector<int>> ans;
  vector<int> path;
  backtracking(ans, path, n, k, 1);
  return ans;
}
```

### 10.2.2. #46 求全排列

```cpp {class=line-numbers}
void backtracking(vector<vector<int>> &ans, vector<int> &path, 
        vector<int> &nums, vector<bool> &used)
{
  if (path.size() == nums.size())
  {
    ans.push_back(path);
    return;
  }

  for (int i = 0; i < nums.size(); ++i)
  {
    if (!used[i])
    {
      used[i] = true;
      path.push_back(nums[i]);
      backtracking(ans, path, nums, used);
      used[i] = false;
      path.pop_back();
    }
  }
}

vector<vector<int>> permute(vector<int> &nums)
{
  vector<vector<int>> ans;
  vector<int> path;
  vector<bool> used(nums.size(), false);
  backtracking(ans, path, nums, used);
  return ans;
}
```

```cpp {class=line-numbers}

```

```cpp {class=line-numbers}

```

```cpp {class=line-numbers}

```

# 11. 复合数据结构

## 11.1. 引言

## 11.2. 相关题目

- #146 LRU 缓存机制
- #684 冗余连接（并查集的应用）

### 11.2.1. #146 LRU 缓存机制

```cpp {class=line-numbers}
class LRUCache
{
public:
  LRUCache(int capacity) : cap(capacity) {}

  int get(int key)
  {
    auto it = hash.find(key);
    if (it == hash.end()) return -1;

    cache.splice(cache.begin(), cache, it->second);
    return it->second->second;
  }

  void put(int key, int value)
  {
    auto it = hash.find(key);
    if (it != hash.end())
    {
      it->second->second = value;
      cache.splice(cache.begin(), cache, it->second);
    }
    else
    {
      cache.push_front({key, value});
      hash[key] = cache.begin();
      if (cache.size() > cap)
      {
        hash.erase(cache.back().first);
        cache.pop_back();
      }
    }
  }

private:
  list<pair<int, int>> cache;
  unordered_map<int, list<pair<int, int>>::iterator> hash;
  int cap;
};
```

```cpp {class=line-numbers}
class DLinkList
{
public:
  struct Node
  {
    int key;
    int value;
    Node *prev;
    Node *next;
    Node(int k = 0, int v = 0) : key(k), value(v), prev(nullptr), next(nullptr) {}
  };

  DLinkList()
  {
    head = new Node;
    tail = new Node;
    head->next = head->prev = tail; //虚拟头节点
    tail->next = tail->prev = head; //虚拟尾节点
  }

  void pushFront(Node *node)
  {
    head->next->prev = node;
    node->next = head->next;
    node->prev = head;
    head->next = node;
  }

  void deleteNode(Node *node)
  {
    node->prev->next = node->next;
    node->next->prev = node->prev;
  }

  Node *popBack()
  {
    Node *ret = tail->prev;
    deleteNode(ret);
    return ret;
  }

private:
  Node *head, *tail;
};

class LRUCache
{
public:
  LRUCache(int capacity) : cap(capacity), size(0) {}

  int get(int key)
  {
    auto it = hash.find(key);
    if (it == hash.end())
      return -1;

    cache.deleteNode(it->second);
    cache.pushFront(it->second);
    return it->second->value;
  }

  void put(int key, int value)
  {
    auto it = hash.find(key);
    if (it != hash.end())
    {
      it->second->value = value;
      cache.deleteNode(it->second);
      cache.pushFront(it->second);
    }
    else
    {
      DLinkList::Node *node = new DLinkList::Node(key, value);
      cache.pushFront(node);
      hash[key] = node;
      ++size;
      if (size > cap)
      {
        DLinkList::Node *back = cache.popBack();
        hash.erase(back->key);
        delete back;
        --size;
      }
    }
  }

private:
  DLinkList cache;
  unordered_map<int, DLinkList::Node *> hash;
  int size;
  int cap;
};
```

### 11.2.2. #684 冗余连接（并查集的应用）

```cpp {class=line-numbers}
// 并查集：查找一个节点的祖先，合并两个不相交的集合
class UF
{
private:
  vector<int> anc; //存储每个节点的祖先
  vector<int> rank; //存储以每个节点为根的子树的深度
public:
  UF(int n) : anc(n + 1, 0), rank(n + 1, 1)
  {
    for (int i = 0; i <= n; ++i)
      anc[i] = i;
  }

  int find(int x)
  {
    // 递归形式的写法
    // return (x == anc[x]) ? x : (anc[x] = find[anc[x]]);

    // 非递归形式的写法
    int p = x;
    while (p != anc[p])
      p = anc[p];       //找祖先
    while (x != anc[x]) //路径压缩
    {
      int tmp = x;
      x = anc[x];
      anc[tmp] = p;
    }
    return p;
  }

  void connect(int x, int y)
  {
    anc[find(y)] = find(x);

    // 同时使用路径压缩和按秩合并会产生冲突
    // int p1 = find(x), p2 = find(y);
    // if (p1 == p2) return;

    // 按秩合并，将深度较小的树合并到深度较大的树
    // if (rank[p1] > rank[p2]) anc[p2] = p1;
    // else if (rank[p1] < rank[p2]) anc[p1] = p2;
    // else
    // {
    //   anc[p1] = p2;
    //   ++rank[p2];
    // }
  }

  bool isConnected(int x, int y)
  {
    return find(x) == find(y);
  }
};

class Solution
{
public:
  vector<int> findRedundantConnection(vector<vector<int>> &edges)
  {
    int n = edges.size();
    UF uf(n);
    for (int i = 0; i < n; ++i)
    {
      if (uf.isConnected(edges[i][0], edges[i][1]))
        return edges[i];
      uf.connect(edges[i][0], edges[i][1]);
    }
    return {-1, -1};
  }
};
```

```cpp {class=line-numbers}

```

```cpp {class=line-numbers}

```

<!-- ## 《剑指offer》面试题3

### 题目1：数组中的重复元素

数组长度为`n`，数组元素的取值范围为`0 ~ n - 1`，求是否存在重复元素

```cpp {class=line-numbers}
// 交换元素，使元素落在其合适的位置
// 时间：O(n)，空间：O(1)
bool containsDuplicate(vector<int>& nums) 
{
  if (nums.size() < 1)
      return false;
  for (int i = 0; i < nums.size(); ++i)
  {
    if (nums[i] < 0 || nums[i] >= nums.size())
      return false;
  }
  
  for (int i = 0; i < nums.size(); ++i)
  {
    while (nums[i] != i)
    {
      if (nums[i] == nums[nums[i]])
        return true;
      
      int tmp = nums[i];
      nums[i] = nums[nums[i]];
      nums[nums[i]] = tmp;
    }
  }

  return false;
}
```

### 题目2：数组中的重复元素

数组长度为`n+1`，数组元素的取值范围为`1 ~ n`，求其中的一个重复元素

```cpp {class=line-numbers}
// 哈希表辅助，时间：O(n)，空间：O(n)
int getDuplication(vector<int> &nums)
{
  if (nums.size() <= 1)
    return -1;

  unordered_map<int, int> count;

  // 初始化哈希表，key为数组元素的值，value为数组元素在数组中的出现次数，初始为0
  for (int i = 0; i < nums.size(); ++i)
    count[nums[i]] = 0;
  
  // 统计各元素在数组中的出现次数
  for (int i = 0; i < nums.size(); ++i)
    ++count[nums[i]];

  // 返回第一个出现次数大于1的元素
  for (int i = 0; i < nums.size(); ++i)
    if (count[nums[i] > 1])
      return nums[i];

  // 没有重复元素
  return -1;
}
```

```cpp {class=line-numbers}
// 折半查找思想，时间：O(nlogn)，空间：O(1)
```

## 阿里牛客笔试题

1. 小强现在有$n$个物品，每个物品有两种属性$x_i$和$y_i$，他想要从中挑出尽可能多的物品满足以下条件：对于任意两个物品$x_i<x_j$且$y_i<y_j$，或者$x_i>x_j$且$y_i>y_j$

```cpp {class=line-numbers}

const int maxn = 1e5 + 10;

struct node
{
  int x, y;
} goods[maxn];

bool cmp(node a, node b)
{
  if (a.x == b.x)
    return a.y > b.y;
  return a.x < b.x;
}

int lengthOfLIS(vector<int> &nums)
{
  int len = 1, n = (int)nums.size();
  if (n == 0)
  {
    return 0;
  }
  vector<int> d(n + 1, 0);
  d[len] = nums[0];
  for (int i = 1; i < n; ++i)
  {
    if (nums[i] > d[len])
    {
      d[++len] = nums[i];
    }
    else
    {
      int l = 1, r = len, pos = 0;
      while (l <= r)
      {
        int mid = (l + r) >> 1;
        if (d[mid] < nums[i])
        {
          pos = mid;
          l = mid + 1;
        }
        else
        {
          r = mid - 1;
        }
      }
      d[pos + 1] = nums[i];
    }
  }
  //for(int i = 1;i <= len;i++) cout<<d[i]<<" ";cout<<endl;
  return len;
}

void solve()
{
  int n;
  cin >> n;
  for (int i = 0; i < n; i++)
  {
    cin >> goods[i].x;
  }
  for (int i = 0; i < n; i++)
  {
    cin >> goods[i].y;
  }
  sort(goods, goods + n, cmp);
  vector<int> vec;
  for (int i = 0; i < n; i++)
  {
    vec.push_back(goods[i].y);
  }
  //for(int i = 0;i < vec.size();i++) cout<<vec[i]<<" ";cout<<endl;
  cout << lengthOfLIS(vec) << endl;
}

int main()
{
  // std::cout << "Func:main() Start\n";

#ifdef TRAING
  const std::string traingFilePath = "E:\\Job\\Markdown-Note\\Code\\trainData1.txt";
  std::freopen(traingFilePath.c_str(), "r", stdin);
#endif

  int T;
  cin >> T;
  while (T--)
  {
    solve();
  }

  // std::cout << "Func:main() end\n";

  return 0;
}
```

```cpp {class=line-numbers}

```

```cpp {class=line-numbers}

```

## 各大公司的笔试题

### 网易

1. 最短回文串：
小易得到了一个仅包含大小写英文字符的字符串，该字符串可能不是回文串。（“回文串”是一个正读和反读都一样的字符串，比如“level”或者“noon”等等就是回文串，“asds”就不是回文串。）小易可以在字符串尾部加入任意数量的任意字符，使其字符串变成回文串。
现在请你编写一个程序，程序要能计算出小易可以得到的最短回文串。

    ```cpp {class=line-numbers}
    #include <bits/stdc++.h>

    using namespace std;

    // 判断字符串s在范围[start, end]是否回文
    bool check(string &s, int start, int end)
    {
      while (start < end)
      {
        if (s[start] != s[end])
          return false;
        ++start;
        --end;
      }
      return true;
    }

    int main()
    {
      string s;
      cin >> s;

      int i = 0;
      // 求最长回文后缀
      for (i = 0; i < s.size(); ++i)
      {
        if (check(s, i, s.size() - 1))
          break;
      }

      // 剩下的前缀的反转即为需要在字符串尾部添加的最短字符序列
      string minAddStr = s.substr(0, i);
      reverse(minAddStr.begin(), minAddStr.end());
      cout << s + minAddStr << endl;
    }
    ```

2. 拆分最多素数：

- 1不是素数，要求将每个数拆成素数最多的方案，2是最小的素数，使劲拆出2即可。 -->

<!-- ### Other

#### #1 两数之和

```cpp {class=line-numbers}
// 暴力枚举，利用两层for循环来遍历每个元素，并查找满足条件的目标元素。
// 时间复杂度为O(N^2)，空间复杂度为O(1)
vector<int> twoSum_1(vector<int> &nums, int target)
{
  vector<int> ret;
  for (int i = 0; i < nums.size() - 1; ++i)
  {
    for (int j = i + 1; j < nums.size(); ++j)
    {
      if ((nums[i] + nums[j]) == target)
      {
        ret.push_back(i);
        ret.push_back(j);
        return ret;
      }
    }
  }
  return ret;
}

// 增加一个Map记录已经遍历过的数字及其对应的索引值。
// 当遍历一个新数字的时候就去Map里查询target与该数的差值是否已经在前面的数字中出现过。
// 如果出现过，就找到了答案，就不必再往下继续执行了。
vector<int> twoSum_2(vector<int> &nums, int target)
{
  unordered_map<int, int> m;
  vector<int> ret;
  for (int i = 0; i < nums.size(); ++i)
  {
    int t = target - nums[i];
    if (m.count(t))
    {
      ret.push_back(m[t]);
      ret.push_back(i);
      return ret;
    }
    m[nums[i]] = i;
  }
  return ret;
}
```

#### #2 两数相加

```cpp {class=line-numbers}
//先比较两个单向链表的长度，将返回值设为较长的链表
ListNode *addTwoNumbers_1(ListNode *l1, ListNode *l2)
{
  ListNode *p1 = l1, *p2 = l2;

  while (l1 && l2)
  {
    l1 = l1->next;
    l2 = l2->next;
  }

  if (l1)
  {
    l1 = p1;
    l2 = p2;
  }
  else
  {
    l1 = p2;
    l2 = p1;
  }

  ListNode *q1 = l1;
  int flag = 0;

  while (l2)
  {
    int next_val = (l1->val + l2->val + flag) % 10;
    int next_flag = (l1->val + l2->val + flag) / 10;
    l1->val = next_val;
    flag = next_flag;
    p1 = l1;
    p2 = l2;
    l1 = l1->next;
    l2 = l2->next;
  }

  while (l1 && flag)
  {
    int next_flag = (l1->val + flag) / 10;
    int next_val = (l1->val + flag) % 10;
    flag = next_flag;
    l1->val = next_val;
    p1 = l1;
    l1 = l1->next;
  }

  if (flag)
  {
    p1->next = new ListNode;
    p1->next->val = flag;
    p1->next->next = nullptr;
    return q1;
  }

  return q1;
}
```

#### #3 无重复字符的最长字串

```cpp {class=line-numbers}
int Solution::lengthOfLongestSubstring(string s)
{
  const char *str = s.c_str();
  return myLengthOfLongestSubstring(str, s.size());
}

int Solution::myLengthOfLongestSubstring(const char *str, int len)
{
  if (len <= 1)
    return len;

  const char *left = str, *right = str + len / 2;
  int max_left = myLengthOfLongestSubstring(left, len / 2);
  int max_right = myLengthOfLongestSubstring(right, len - len / 2);
  int max_mid = midLengthOfLongestSubstring(str, len);
  if (max_left > max_right)
    return (max_left > max_mid) ? max_left : max_mid;
  else
    return (max_right > max_mid) ? max_right : max_mid;
}

int Solution::midLengthOfLongestSubstring(const char *str, int len)
{
  unordered_map<char, bool> m1, m2;
  for (int i = 0; i < len; ++i)
  {
    m1[str[i]] = false;
    // m2[str[i]] = false;
  }

  bool flag1 = true, flag2 = true;
  int i = len / 2 - 1, j = len / 2;
  int left = 0, right = len - 1;
  while (flag1 || flag2)
  {
    if (flag1)
    {
      if (m1[str[i]])
      {
        flag1 = false;
        left = i + 1;
      }
      else
      {
        m1[str[i]] = true;
        --i;
        if (i == -1)
        {
          left = 0;
          flag1 = false;
        }
      }
    }

    if (flag2)
    {
      if (m1[str[j]])
      {
        flag2 = false;
        right = j - 1;
      }
      else
      {
        m1[str[j]] = true;
        ++j;
        if (j == len)
        {
          right = len - 1;
          flag2 = false;
        }
      }
    }
  }

  return (right - left + 1);
}

```

#### #4 寻找两个正序数组中的中位数

```cpp {class=line-numbers}
//低效率解法，先将数组1插入数组2，再算中位数
double findMedianSortedArrays(vector<int> &nums1, vector<int> &nums2)
{
  int len1 = nums1.size(), len2 = nums2.size();
  int len = len1 + len2;
  if (len == 0)
    return 0;
  if (len1 == 0)
    return (len % 2 == 0) ? (nums2[len / 2] + nums2[len / 2 - 1]) / 2.0 : nums2[len / 2];
  if (len2 == 0)
    return (len % 2 == 0) ? (nums1[len / 2] + nums1[len / 2 - 1]) / 2.0 : nums1[len / 2];

  int insert_index = 0;
  for (int i = 0; i < len2; i++)
  {
    int j = 0;
    for (j = insert_index; j < len1 && nums1[j] < nums2[i]; j++)
    {
    }
    nums1.insert(nums1.begin() + j, nums2[i]);
    len1 = nums1.size();
    insert_index = j + 1;
  }
  return (len % 2 == 0) ? (nums1[len / 2 - 1] + nums1[len / 2]) / 2.0 : nums1[len / 2];
}
```

#### #217 数组中的重复元素

给定一个整数数组，判断是否存在重复元素。如果存在一值在数组中出现至少两次，函数返回`true`。如果数组中每个元素都不相同，则返回`false`。

```cpp {class=line-numbers}
// 哈希表辅助求解
bool containsDuplicate(vector<int>& nums) 
{
  if (nums.size() == 0)
      return false;
  unordered_map<int, int> count;
  
  for (int i = 0; i < nums.size(); i++)
  {
      count[nums[i]] = 0;
  }

  for (int i = 0; i < nums.size(); i++)
  {
      if (count[nums[i]])
        return true;
      ++count[nums[i]];
  }
  return false;
  // return set<int>(nums.begin(), nums.end()).size() != nums.size();
}
```

#### #219 数组中的重复元素

给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引`i`和`j`，使得`nums[i] = nums[j]`，并且`i`和`j`的差的绝对值至多为`k`。

```cpp {class=line-numbers}
bool containsNearbyDuplicate(vector<int>& nums, int k) 
{
  if (nums.size() <= 1)
    return false;
  
  unordered_map<int, int> count;

  for (int i = 0; i < nums.size(); ++i)
    count[nums[i]] = -1;
  
  for (int i = 0; i < nums.size(); ++i)
  {
    if ((count[nums[i]] != -1) && (i - count[nums[i]] <= k))
        return true;
    count[nums[i]] = i;
  }
  return false;
}
```

#### #220 数组与滑动窗口

给你一个整数数组`nums`和两个整数`k`和`t`。请你判断是否存在两个不同下标`i`和`j`，使得`abs(nums[i] - nums[j]) <= t` ，同时又满足`abs(i - j) <= k`。如果存在则返回`true`，不存在返回`false`

```cpp {class=line-numbers}
// 暴力解法，注意整数算术溢出
bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) 
{
  if (nums.size() <= 1 || k < 1)
    return false;

  k = (k <= nums.size() - 1 ? k : nums.size() - 1);
  for (int j = 1; j <= k; ++j)
  {
    for (int i = 0; i <= nums.size() - j - 1; ++i)
    {
        if (fabs((long)nums[i] - (long)nums[i + j]) <= t)
            return true;
    }
  }
  return false;
}
``` -->
