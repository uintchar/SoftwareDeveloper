# 数据结构与算法题目总结

## Leetcode刷题

### 1. 数组

#### 1.1 二分查找

- STL中关于二分查找的函数有三个`lower_bound、upper_bound、binary_search`。这三个函数都运用于有序区间.
  - `ForwardIter lower_bound(ForwardIter first, ForwardIter last, const _Tp &val)`算法返回一个非递减序列`[first, last)`中的第一个大于等于值val的位置；
  - `ForwardIter upper_bound(ForwardIter first, ForwardIter last, const _Tp& val)`算法返回一个非递减序列`[first, last)`中的第一个大于值val的位置；

- 相关题目：
  - #704 二分查找
  - #35 搜索插入位置
  - #34 在排序数组中查找元素的第一个和最后一个位置
  - #69 $x$ 的平方根
  - #367 有效的完全平方数
  - #33 搜索旋转排序数组
  - #81 搜索旋转排序数组 II
  - #154 寻找旋转排序数组中的最小值 II（待完成）
  - #540 有序数组中的单一元素（待完成）
  - #4 寻找两个正序数组的中位数（待完成）

##### #704 二分查找

```cpp {class=line-numbers}
// 左闭右闭写法
int binSearch(vector<int> &nums, int target)
{
  int l = 0, r = nums.size() - 1;
  while (l <= r)
  {
    int mid = (l + r) / 2;
    if (nums[mid] > target)
      r = mid - 1;
    else if (nums[mid] < target)
      l = mid + 1;
    else
      return mid;
  }
  return -1;
}
```

```cpp {class=line-numbers}
// 左闭右开写法
int binSearch(vector<int> &nums, int target)
{
  int l = 0, r = nums.size();
  while (left < right)
  {
    int mid = (l + r) / 2;
    if (nums[mid] > target)
      r = mid;
    else if (nums[mid] < target)
      l = mid + 1;
    else
      return mid;
  }
  return -1;
}
```

##### #35 搜索插入位置

给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。你可以假设数组中无重复元素。

```cpp {class=line-numbers}
// 暴力解法
int searchInsert(vector<int> &nums, int target)
{
  for (int i = 0; i < nums.size(); i++)
  {
    // 处理如下三种情况：目标值在数组所有元素之前；等于数组中某一个元素；插入数组中的位置
    if (nums[i] >= target)
      return i;
    }
  }
  // 目标值在数组所有元素之后的情况
  return nums.size();
}
```

```cpp {class=line-numbers}
// 二分法
int searchInsert(vector<int> &nums, int target)
{
  int n = nums.size();
  // 插入位置为最左边
  if (n < 1 || target < nums[0])
    return 0;

  // 插入位置在最右边
  if (target > nums[n - 1])
    return n;

  // 目标值存在数组内
  int l = 0, r = n - 1;
  while (l <= r)
  {
    int mid = (l + r) / 2;
    if (nums[mid] == target)
      return mid;
    else if (nums[mid] > target)
      r = mid - 1;
    else
      l = mid + 1;
  }

  // 插入位置为数组内部
  return r + 1;
}
```

##### #34 在排序数组中查找元素的第一个和最后一个位置

给定一个按照升序排列的整数数组`nums`，和一个目标值`target`。找出给定目标值在数组中的开始位置和结束位置。如果数组中不存在目标值`target`，返回`[-1, -1]`。
进阶：你可以设计并实现时间复杂度为$O(logn)$的算法解决此问题吗？

```cpp {class=line-numbers}
// 暴力解法
vector<int> searchRange(vector<int> &nums, int target)
{
  vector<int> ret = {-1, -1};
  int n = nums.size();
  if (n < 1)
    return ret;

  for (int i = 0; i < n; ++i)
  {
    if (nums[i] == target)
    {
      ret[0] = ret[1] = i;
      int j = i + 1;
      while (j < n && nums[j] == target)
        ++j;
      ret[1] = j - 1;
      break;
    }
  }

  return ret;
}
```

```cpp {class=line-numbers}
// 二分查找
vector<int> searchRange(vector<int> &nums, int target)
{
  if (nums.empty())
    return vector<int>{-1, -1};

  int lower = lower_bound(nums, target);
  int upper = upper_bound(nums, target) - 1; // 这里需要减1位

  if (lower == nums.size() || nums[lower] != target)
    return vector<int>{-1, -1};
  return vector<int>{lower, upper};
}

// 辅函数
int lower_bound(vector<int> &nums, int target)
{
  int l = 0, r = nums.size() - 1, mid;
  while (l <= r)
  {
    mid = (l + r) / 2;
    if (nums[mid] >= target)
      r = mid - 1;
    else
      l = mid + 1;
  }
  return l;
}

// 辅函数
int upper_bound(vector<int> &nums, int target)
{
  int l = 0, r = nums.size() - 1, mid;
  while (l <= r)
  {
    mid = (l + r) / 2;
    if (nums[mid] > target)
      r = mid - 1;
    else
      l = mid + 1;
  }
  return l;
}
```

##### #69 x 的平方根

实现`int sqrt(int x)`函数。计算并返回`x`的平方根，其中`x`是非负整数。由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。

```cpp {class=line-numbers}
// 二分查找（左闭右闭）思想
int mySqrt(int x)
{
  if (x == 0)
    return 0;

  long long l = 1, r = x, mid = 0;
  while (l <= r)
  {
    mid = (l + r) / 2;
    if (mid * mid < x)
      l = mid + 1;
    else if (mid * mid > x)
      r = mid - 1;
    else
      return mid;
  }
  return r;
}

// 牛顿迭代法？？？
```

##### #367 有效的完全平方数

```cpp {class=line-numbers}
bool isPerfectSquare(int num)
{
  if (num == 0)
    return true;

  long long l = 1, r = num, mid = 0;
  while (l <= r)
  {
    mid = (l + r) / 2;
    if (mid * mid > num)
      r = mid - 1;
    else if (mid * mid < num)
      l = mid + 1;
    else
      return true;
  }
  return false;
}
```

##### #33 搜索旋转排序数组

整数数组`nums`按升序排列，数组中的值互不相同。在传递给函数之前，`nums`在预先未知的某个下标`k（0 <= k < nums.length）`上进行了旋转，使数组变为`[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]`（下标从`0`开始计数）。给你旋转后的数组`nums`和一个整数`target`，如果`nums`中存在这个目标值`target`，则返回它的下标，否则返回`-1`。

```cpp {class=line-numbers}
int search(vector<int> &nums, int target)
{
  int n = nums.size();
  int l = 0, r = n - 1, mid = 0;

  while (l <= r)
  {
    mid = (l + r) / 2;
    if (nums[mid] == target) return mid;
    if (nums[mid] >= nums[l]) // 数组左边有序
    {
      if (nums[mid] > target && nums[l] <= target) // 目标值是否在左边有序数组内？
        r = mid - 1;
      else
        l = mid + 1;
    }
    else if (nums[mid] <= nums[r]) // 数组右边有序
    {
      if (nums[mid] < target && nums[r] >= target) // 目标值是否在右边有序数组内？
        l = mid + 1;
      else
        r = mid - 1;
    }
  }
  return -1;
}
```

##### #81 搜索旋转排序数组 II

相对于#33，数组中的存在重复的值

```cpp {class=line-numbers}
// 时间复杂度：O(n)，最坏情况下数组元素均相等且不为target，我们需要访问所有位置才能得出果。
// 空间复杂度：O(1)。
bool search(vector<int> &nums, int target)
{
  int n = nums.size();
  int l = 0, r = n - 1, mid = 0;

  while (l <= r)
  {
    mid = (l + r) / 2;
    if (nums[mid] == target)
      return true;

    if (nums[mid] < nums[r]) // 右区间有序
    {
      if (nums[mid] < target && nums[r] >= target)
        l = mid + 1;
      else
        r = mid - 1;
    }
    else if (nums[mid] > nums[l]) // 左区间有序
    {
      if (nums[mid] > target && nums[l] <= target)
        r = mid - 1;
      else
        l = mid + 1;
    }
    else if (nums[mid] == nums[l]) // 无法区分左区间是否有序
      ++l;
    else if (nums[mid] == nums[r]) // 无法区分右区间是否有序
      --r;
  }
  return false;
}

```

##### #154 寻找旋转排序数组中的最小值 II

```cpp {class=line-numbers}

```

##### #540 有序数组中的单一元素

```cpp {class=line-numbers}

```

##### #4 寻找两个正序数组的中位数

```cpp {class=line-numbers}

```

#### 1.2 双指针

- 双指针主要用于遍历数组，两个指针指向不同的元素，从而协同完成任务。也可以延伸到多个数组的多个指针。
- 若两个指针指向同一数组，遍历方向相同且不会相交，则也称为滑动窗口（两个指针包围的区域即为当前的窗口），经常用于区间搜索。
- 若两个指针指向同一数组，但是遍历方向相反，则可以用来进行搜索，待搜索的数组往往是排好序的。
- 相关题目：
  - #15 三数之和
  - #18 四数之和
  - #27 移除元素
  - #26 删除排序数组中的重复项
  - #283 移动零
  - #844 比较含退格的字符串
  - #977 有序数组的平方
  - #167 两数之和 II - 输入有序数组
  - #88 合并两个有序数组
  - #142 环形链表 II

##### #15 三数之和

```cpp {class=line-numbers}
// 双指针法，注意去除重复元组
vector<vector<int>> threeSum(vector<int> &nums)
{
  vector<vector<int>> ans;
  if (nums.size() < 3) return ans;

  sort(nums.begin(), nums.end());
  for (int i = 0; i < nums.size() - 2; ++i)
  {
    if (nums[i] > 0) return ans; // 排序后若首元素大于0，则不存在三数之和大于0
    if (i > 0 && nums[i] == nums[i - 1]) continue; // 去除重复的元组

    int left = i + 1, right = nums.size() - 1;
    while (left < right)
    {
      if (nums[i] + nums[left] + nums[right] < 0) ++left;
      else if (nums[i] + nums[left] + nums[right] > 0) --right;
      else
      {
        ans.push_back({nums[i], nums[left], nums[right]});
        while (left < right && nums[left + 1] == nums[left]) ++left;
        while (left < right && nums[right - 1] == nums[right]) --right;
        ++left; --right;
      }
    }
  }

  return ans;
}
```

##### #18 四数之和

```cpp {class=line-numbers}
vector<vector<int>> fourSum(vector<int> &nums, int target)
{
  vector<vector<int>> ans;
  if (nums.size() < 4) return ans;

  sort(nums.begin(), nums.end());
  for (int i = 0; i < nums.size() - 3; ++i)
  {
    if (i > 0 && nums[i] == nums[i - 1]) continue;

    for (int j = i + 1; j < nums.size() - 2; ++j)
    {
      if (j > i + 1 && nums[j] == nums[j - 1]) continue;

      int left = j + 1, right = nums.size() - 1;
      while (left < right)
      {
        if (nums[i] + nums[j] + nums[left] + nums[right] < target) ++left;
        else if (nums[i] + nums[j] + nums[left] + nums[right] > target) --right;
        else
        {
          ans.push_back({nums[i], nums[j], nums[left], nums[right]});
          while (left < right && nums[left + 1] == nums[left]) ++left;
          while (left < right && nums[right - 1] == nums[right]) --right;
          ++left; --right;
        }
      }
    }
  }
  return ans;
}
```

##### #27 移除元素

```cpp {class=line-numbers}
// 快慢指针，通过fast指针找到下一个不等于val的元素放到slow位置
int removeElement(vector<int> &nums, int val)
{
  int fast = 0, slow = 0;
  while (fast < nums.size())
  {
    if (val == nums[fast])
      fast++;
    else
      nums[slow++] = nums[fast++];
  }
  return slow;
}
```

##### #26 删除排序数组中的重复项

```cpp {class=line-numbers}
// 通过fast指针找到第一个不重复的元素放到slow位置
int removeDuplicates(vector<int> &nums)
{
  if (nums.size() <= 1)
    return nums.size();

  int fast = 1, slow = 1;
  while (fast < nums.size())
  {
    if (nums[fast] == nums[fast - 1])
      fast++;
    else
      nums[slow++] = nums[fast++];
  }
  return slow;
}
```

##### #283 移动零

```cpp {class=line-numbers}
void moveZeroes(vector<int> &nums)
{
  int fast = 0, slow = 0;
  while (fast < nums.size())
  {
    if (nums[fast] == 0)
      fast++;
    else
      nums[slow++] = nums[fast++];
  }

  for (int i = slow; i < nums.size(); ++i)
    nums[i] = 0;
}
```

##### #844 比较含退格的字符串

```cpp {class=line-numbers}
// 从后往前比，某个字符是否被删除掉，只与其前面的'#'有关
// string S = "bxj##tw", T = "bxo#j##tw"
bool backspaceCompare(string S, string T)
{
  int i = S.size() - 1, j = T.size() - 1;

  while (i >= 0 || j >= 0)
  {
    int delSNum = 0, delTNum = 0;

    // 找到S中第一个要比较的字符
    while (i >= 0)
    {
      if (S[i] == '#')
      {
        ++delSNum;
        --i;
      }
      else if (delSNum > 0)
      {
        --delSNum;
        --i;
      }
      else
        break;
    }

    // 找到T中第一个要比较的字符
    while (j >= 0)
    {
      if (T[j] == '#')
      {
        ++delTNum;
        --j;
      }
      else if (delTNum > 0)
      {
        --delTNum;
        --j;
      }
      else
        break;
    }

    if (i < 0 && j < 0)
      return true;
    if ((i < 0 && j >= 0) || (i >= 0 && j < 0))
      return false;

    if (S[i] != T[j])
      return false;
    else
    {
      --i;
      --j;
    }
  }
  return true;
}
```

##### #977 有序数组的平方

```cpp {class=line-numbers}
vector<int> sortedSquares(vector<int> &nums)
{
  vector<int> ret(nums.size(), 0);
  int pos = nums.size() - 1;
  for (int i = 0, j = nums.size() - 1; i <= j;)
  {
    if (nums[i] * nums[i] < nums[j] * nums[j])
    {
      ret[pos--] = nums[j] * nums[j];
      j--;
    }
    else
    {
      ret[pos--] = nums[i] * nums[i];
      i++;
    }
  }
  return ret;
}
```

##### #167 两数之和 II - 输入有序数组

```cpp {class=line-numbers}
vector<int> twoSum(vector<int> &numbers, int target)
{
  vector<int> ret(2, 0);
  int l = 0, r = numbers.size() - 1;

  while (l < r)
  {
    if (numbers[l] + numbers[r] == target)
    {
      ret[0] = l + 1;
      ret[1] = r + 1;
      return ret;
    }
    if (numbers[l] + numbers[r] < target) // 两数和小于目标值，左指针右移一位
      ++l;
    else // 两数和大于目标值，右指针左移一位
      --r;
  }
  return ret;
}
```

##### #88 合并两个有序数组

```cpp {class=line-numbers}
void merge(vector<int> &nums1, int m, vector<int> &nums2, int n)
{
  int p1 = m - 1, p2 = n - 1, p3 = m + n - 1;
  while (p2 >= 0)
  {
    if (p1 < 0)
    {
      for (int i = 0; i <= p2; ++i)
        nums1[i] = nums2[i];
      break;
    }

    if (nums1[p1] < nums2[p2])
      nums1[p3--] = nums2[p2--];
    else
      nums1[p3--] = nums1[p1--];
  }
}
```

##### #142 环形链表 II

对于链表找环路的问题，有一个通用的解法——快慢指针（Floyd判圈法）。给定两个指针，分别命名为 `slow`和`fast`，起始位置在链表的开头。每次`fast`前进两步，`slow`前进一步。如果`fast`可以走到尽头，那么说明没有环路；如果`fast`可以无限走下去，那么说明一定有环路，且一定存在一个时刻 `slow`和`fast`相遇。当`slow`和`fast`第一次相遇时，我们将`fast`重新移动到链表开头，并让`slow`和`fast`每次都前进一步。当`slow`和`fast`第二次相遇时，相遇的节点即为环路的开始点。

```cpp {class=line-numbers}
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
ListNode *detectCycle(ListNode *head)
{
  ListNode *fast = head, *slow = head;
  
  do
  {
    if (!fast || !fast->next) // fast是否可以走到尽头？
      return nullptr;
    fast = fast->next->next; // fast走两步
    slow = slow->next; // slow走一步
  } while (fast != slow); // 当fast和slow首次相遇时代表存在环路 

  fast = head;
  while (fast != slow)
  {
    fast = fast->next;
    slow = slow->next;
  }
  return fast;
}
```

#### 1.3 滑动窗口

- 相关题目
  - #209 长度最小的子数组
  - #904 水果成篮
  - #76 最小覆盖子串

##### #209 长度最小的子数组

```cpp {class=line-numbers}
// 暴力解法，以数组中的每个元素为起点开始
int minSubArrayLen(int target, vector<int> &nums)
{
  int minLen = nums.size() + 1;
  for (int i = 0; i < nums.size(); ++i)
  {
    int sum = 0, j = i;
    while (sum < target)
    {
      sum += nums[j++];
      if (j >= nums.size())
        break;
    }
    if (sum >= target && minLen > j - i)
      minLen = j - i;
  }

  if (minLen != nums.size() + 1)
    return minLen;
  else
    return 0;
}
```

```cpp {class=line-numbers}
// 滑动窗口解法
int minSubArrayLen(int target, vector<int> &nums)
{
  if (nums.size() == 0)
    return 0;

  int start = 0, end = 0, minLen = nums.size() + 1;
  int sum = 0;
  while (end < nums.size())
  {
    sum += nums[end];
    while (sum >= target)
    {
      minLen = min(minLen, end - start + 1);
      sum -= nums[start];
      ++start;
    }
    ++end;
  }
  return (minLen == nums.size() + 1) ? 0 : minLen;
}
```

##### #904 水果成篮

剥掉马甲该题本质就是求最多包含两个（k=2）不同字符的最大窗口大小。

```cpp {class=line-numbers}
int totalFruit(vector<int> &tree)
{
  unordered_map<int, int> window;
  const int k = 2;
  int start = 0, end = 0, maxLen = 0;

  while (end < tree.size())
  {
    window[tree[end]]++;
    // 当窗口内包含了多于k个不同的字符时，滑动窗口左端点直至窗口内只包含两种不同的字符
    while (window.size() > k)
    {
      window[tree[start]]--;
      if (window[tree[start]] == 0)
        window.erase(tree[start]);
      ++start;
    }
    maxLen = max(maxLen, end - start + 1);
    ++end;
  }
  return maxLen;
}
```

##### #76 最小覆盖子串

```cpp {class=line-numbers}
string minWindow(string S, string T)
{
  // 先统计T中的字符情况，同时need中记录了窗口内需要的字符情况
  unordered_map<char, int> need;
  for (int i = 0; i < T.size(); ++i)
    need[T[i]] = 0;
  for (int i = 0; i < T.size(); ++i)
    ++need[T[i]];

  int start = 0, end = 0, minStart = 0, minLen = S.size() + 1, needNum = T.size();
  while (end < S.size())
  {
    // 窗口内增加了一个需要的字符
    if (need.find(S[end]) != need.end())
    {
      // 将该字符所需数目减1，当该字符所需数目仍大于0时，将总的所需字符目减1
      if (--need[S[end]] >= 0)
        --needNum;

      // 若目前滑动窗口已包含T中全部字符，则尝试将l右移，在不影响结果的情况下获得最短子字符串
      while (needNum == 0)
      {
        if (minLen > end - start + 1) // 该窗口比原来满足需求的窗口小？
        {
          minLen = end - start + 1;
          minStart = start;
        }

        // 窗口端点左移可能会使得所需字符数变大
        if ((need.find(S[start]) != need.end()) && ++need[S[start]] > 0)
          ++needNum;
        ++start;
      }
    }
    ++end;
  }
  return (minLen == S.size() + 1) ? "" : S.substr(minStart, minLen);
}
```

#### 1.4 模拟行为

- 相关题目：
  - #54. 螺旋矩阵
  - #59. 螺旋矩阵 II

##### #54. 螺旋矩阵

```cpp {class=line-numbers}

```

##### #59. 螺旋矩阵 II

```cpp {class=line-numbers}

```

### 2. 字符串

#### 2.1 引言

#### 2.2 相关题目

- #344 反转字符串
- #541 反转字符串II

##### #541 反转字符串II

```cpp {class=line-numbers}
string reverseStr(string s, int k)
{
  for (int i = 0; i < s.size(); i += 2 * k)
  {
    if (s.size() - i >= k)
      reverse(s, i, i + k - 1);
    else
      reverse(s, i, s.size() - 1);
  }
  return s;
}

void reverse(string &s, int left, int right)
{
  while (left < right)
  {
    swap(s[left], s[right]);
    ++left;
    --right;
  }
}
```

```cpp {class=line-numbers}

```

```cpp {class=line-numbers}

```

### 3. 链表

#### 3.1 链表的增删改查

- 相关题目：
  - #203. 移除链表元素
  - #707 设计链表

##### #203. 移除链表元素

```cpp {class=line-numbers}
// 不设置虚拟头节点需要考虑当删除的节点为头节点时的特殊情况
ListNode *removeElements(ListNode *head, int val)
{
  ListNode *cur = head, *pre = nullptr;

  while (cur)
  {
    if (cur == head && cur->val == val) // 如果待删除的节点是头节点
    {
      cur = cur->next;
      // delete head;
      head = cur;
    }
    else if (cur->val == val)
    {
      cur = cur->next;
      // delete q->next;
      pre->next = cur;
    }
    else
    {
      pre = cur;
      cur = cur->next;
    }
  }
  return head;
}
```

```cpp {class=line-numbers}
// 设置虚拟头节点
ListNode *removeElements(ListNode *head, int val)
{
  ListNode *virHead = new ListNode;
  virHead->next = head;

  ListNode *p = head, *q = virHead; // q记录着p的前驱
  while (p)
  {
    if (p->val == val)
    {
      p = p->next;
      // delete q->next;
      q->next = p;
    }
    else
    {
      q = p;
      p = p->next;
    }
  }

  head = virHead->next;
  delete virHead;
  return head;
}
```

##### #707 设计链表

```cpp {class=line-numbers}
class MyLinkedList
{
public:
  struct ListNode
  {
    int val;
    ListNode *next;
    ListNode(int x = 0) : val(x), next(nullptr) {}
  };

  MyLinkedList() : head(nullptr) {}

  int get(int index)
  {
    int count = 0;
    ListNode *p = head;
    while (p)
    {
      if (count == index)
        return p->val;
      count++;
      p = p->next;
    }
    return -1;
  }

  void addAtHead(int val)
  {
    ListNode *tmp = new ListNode(val);
    tmp->next = head;
    head = tmp;
  }

  void addAtTail(int val)
  {
    ListNode *tmp = new ListNode(val);
    if (!head) // 如果链表为空
      head = tmp;

    ListNode *p = head, *q = head;
    while (p)
    {
      q = p;
      p = p->next;
    }

    q->next = tmp;
  }

  void addAtIndex(int index, int val)
  {
    ListNode *tmp = new ListNode(val);

    if (index <= 0) // 插入头部
    {
      tmp->next = head;
      head = tmp;
      return;
    }

    ListNode *p = head, *q = head;
    int count = 0;
    while (p)
    {
      if (count == index)
      {
        tmp->next = p;
        q->next = tmp;
        return;
      }
      else
      {
        q = p;
        p = p->next;
        ++count;
      }
    }
    if (count == index) // 插入尾部
    {
      tmp->next = p;
      q->next = tmp;
      return;
    }
  }

  void deleteAtIndex(int index)
  {
    ListNode *p = head, *q = head;
    int count = 0;
    while (p)
    {
      if (count == index && index == 0)
      {
        p = p->next;
        head = p;
        q = head;
        return;
      }
      else if (count == index)
      {
        q->next = p->next;
        return;
      }
      else
      {
        q = p;
        p = p->next;
        ++count;
      }
    }
  }

private:
  ListNode *head;
};

/**
 * Your MyLinkedList object will be instantiated and called as such:
 * MyLinkedList* obj = new MyLinkedList();
 * int param_1 = obj->get(index);
 * obj->addAtHead(val);
 * obj->addAtTail(val);
 * obj->addAtIndex(index,val);
 * obj->deleteAtIndex(index);
 */
```

#### 3.2 链表的经典题目

- 相关题目：
  - #206 翻转链表（链表逆序）
  - #19 删除链表的倒数第 N 个结点
  - #142 环形链表II
  - #21 合并两个有序链表
  - #24 两两交换链表中的节点
  - #160 相交链表

##### #206 翻转链表（链表逆序）

```cpp {class=line-numbers}
// 非递归形式的写法
ListNode *reverseList(ListNode *head)
{
  ListNode *pre = nullptr, *cur = head;
  while (cur)
  {
    ListNode *tmp = cur->next;
    cur->next = pre;
    pre = cur;
    cur = tmp;
  }
  return pre;
}
```

```cpp {class=line-numbers}
// 递归形式的写法
ListNode *reverse(ListNode *pre, ListNode *cur)
{
  if (!cur)
    return pre;
  ListNode *tmp = cur->next;
  cur->next = pre;
  // pre = cur;
  // cur = tmp;
  return reverse(cur, tmp);
}

ListNode *reverseList(ListNode *head)
{
  ListNode *pre = nullptr, *cur = head;
  return reverse(pre, cur);
}
```

##### #19 删除链表的倒数第 N 个结点

```cpp {class=line-numbers}
// 只用一遍扫描实现
ListNode *removeNthFromEnd(ListNode *head, int n)
{
  if (!head)
    return nullptr;

  ListNode *slow = head, *fast = head, *pre = nullptr;
  int cnt = n;

  // 先让快指针走n步
  while (cnt)
  {
    fast = fast->next;
    cnt--;
  }

  // 然后让慢指针和快指针同时走，当慢指针走到尽头时，慢指针的位置即为倒数第n个结点
  while (fast)
  {
    pre = slow;
    slow = slow->next;
    fast = fast->next;
  }

  if (slow == head)
    head = slow->next;
  else
    pre->next = slow->next;
  return head;
}
```

##### #142 环形链表II

```cpp {class=line-numbers}
// 见双指针的章节
ListNode *detectCycle(ListNode *head)
{
  ListNode *fast = head, *slow = head;
  bool isCycle = false;

  while (fast && fast->next)
  {
    fast = fast->next->next;
    slow = slow->next;
    if (fast == slow)
    {
      isCycle = true;
      break;
    }
  }

  if (!isCycle) // 链表中不存在环
    return nullptr;

  fast = head;
  while (fast != slow)
  {
    fast = fast->next;
    slow = slow->next;
  }
  return fast;
}
```

##### #21 合并两个有序链表

```cpp {class=line-numbers}
// 非递归形式的写法
ListNode *mergeTwoLists(ListNode *l1, ListNode *l2)
{
  ListNode *virHead = new ListNode;
  ListNode *p = virHead;

  while (l1 && l2)
  {
    if (l1->val < l2->val)
    {
      p->next = l1;
      l1 = l1->next;
    }
    else
    {
      p->next = l2;
      l2 = l2->next;
    }
    p = p->next;
  }

  p->next = l1 ? l1 : l2;
  ListNode *head = virHead->next;
  delete virHead;
  return head;
}
```

```cpp {class=line-numbers}
// 递归形式的写法
ListNode *mergeTwoLists(ListNode *l1, ListNode *l2)
{
  if (!l1) return l2;
  if (!l2) return l1;

  if (l1->val < l2->val)
  {
    l1->next = mergeTwoLists(l1->next, l2);
    return l1;
  }
  else
  {
    l2->next = mergeTwoLists(l1, l2->next);
    return l2;
  }
}
```

##### #24 两两交换链表中的节点

```cpp {class=line-numbers}
// 不交换节点中的内容而直接交换指针
ListNode *swapPairs(ListNode *head)
{
  if (!head || !head->next)
    return head;

  // 先处理前两个节点，获得新的头指针
  ListNode *tmp = head->next;
  head->next = head->next->next;
  tmp->next = head;
  head = tmp;

  // 处理后续节点
  ListNode *cur = head->next->next, *pre = head->next;
  while (cur && cur->next)
  {
    ListNode *tmp2 = cur->next->next;
    pre->next = cur->next;
    cur->next->next = cur;
    cur->next = tmp2;
    pre = cur;
    cur = tmp2;
  }
  return head;
}
```

##### #160 相交链表

- 假设链表 A 的头节点到相交点的距离是 a，链表 B 的头节点到相交点的距离是 b，相交点到链表终点的距离为 c。我们使用两个指针，分别指向两个链表的头节点，并以相同的速度前进，若到达链表结尾，则移动到另一条链表的头节点继续前进。按照这种前进方法，两个指针会在a + b + c 次前进后同时到达相交节点。
- 若两个链表无相交的节点，则虽然A和B两个链表长度可能不同，但是A+B和B+A的长度是相同的，所以遍历A+B和遍历B+A一定是同时结束。

```cpp {class=line-numbers}
ListNode *getIntersectionNode(ListNode *headA, ListNode *headB)
{
  ListNode *p1 = headA, *p2 = headB;

  while (p1 != p2)
  {
    p1 = (p1 ? p1->next : headB);
    p2 = (p2 ? p2->next : headA);
  }
  return p1;
}
```

##### #234 回文链表

```cpp {class=line-numbers}
// 方法1：空间换时间，将链表中的值复制到数组中，然后使用双指针判断回文
bool isPalindrome(ListNode *head)
{
  if (!head || !head->next)
    return true;

  ListNode *p = head;
  vector<int> arr;
  while (p)
  {
    arr.push_back(p->val);
    p = p->next;
  }

  int left = 0, right = arr.size() - 1;
  while (left <= right)
  {
    if (arr[left++] != arr[right--])
      return false;
  }
  return true;
}
```

```cpp {class=line-numbers}
// 方法2：空间复杂度O(1)，快慢指针
步骤1：找到前半部分链表的尾节点。
步骤2：反转后半部分链表。
步骤3：判断是否回文。
步骤4：恢复链表。
步骤5：返回结果。

步骤1：
可以计算链表节点的数量，然后遍历链表找到前半部分的尾节点。
可以使用快慢指针在一次遍历中找到：慢指针一次走一步，快指针一次走两步，快慢指针同时出发。当
快指针移动到链表的末尾时，慢指针恰好到链表的中间。通过慢指针将链表分为两部分。
若链表有奇数个节点，则中间的节点应该看作是前半部分。

步骤2可以使用「206. 反转链表」问题中的解决方法来反转链表的后半部分。

步骤3比较两个部分的值，当后半部分到达末尾则比较完成，可以忽略计数情况中的中间节点。

步骤4与步骤2使用的函数相同，再反转一次恢复链表本身。

```

```cpp {class=line-numbers}

```

```cpp {class=line-numbers}

```

### 4. 栈和队列

#### 4.1 引言

#### 4.2 相关题目

```cpp {class=line-numbers}

```

```cpp {class=line-numbers}

```

```cpp {class=line-numbers}

```

### 5. 哈希表

#### 5.1 引言

- STL中的哈希表

#### 5.2 相关题目

- 相关题目：
  - #242 有效的字母异位词；
  - #349 两个数组的交集；
  - #202 快乐数
  - #1 两数之和(#167 两数之和 II - 输入有序数组；#170 两数之和 III - 数据结构设计；#653 两数之和 IV - 输入 BST)
  - #454 四数相加 II
  - #15 三数之和（双指针法）
  - #18 四数之和

##### #1 两数之和

```cpp {class=line-numbers}
// 借助哈希表可以只用一次遍历就能解题，哈希表用于记录已经访问过的元素的下标
vector<int> twoSum(vector<int> &nums, int target)
{
  unordered_map<int, int> m;
  for (int i = 0; i < nums.size(); ++i)
  {
    int t = target - nums[i];
    // if (m.count(t))
    if (m.find(t) != m.end())
      return vector<int>{m[t], i};
    m[nums[i]] = i;
  }
  return {};
}
```

##### #454 四数相加 II

```cpp {class=line-numbers}
int fourSumCount(vector<int> &nums1, vector<int> &nums2, vector<int> &nums3, vector<int> &nums4)
{
  unordered_map<int, int> um;

  for (auto a : nums1)
    for (auto b : nums2)
      um[a + b]++; // 初始化时为0？？？

  int count = 0;
  for (auto c : nums3)
    for (auto d : nums4)
    {
      if (um.find(0 - c - d) != um.end())
        count += um[0 - c - d];
    }
  return count;
}
```

```cpp {class=line-numbers}

```

```cpp {class=line-numbers}

```

```cpp {class=line-numbers}

```

### 6. 树

#### 6.1 引言

#### 6.2 相关题目

- #144、#94、#145 二叉树的前中后序遍历，递归方法；
- #144、#94、#145 二叉树的前中后序遍历，迭代方法；
- #102 二叉树的层序遍历
  - #107 二叉树的层次遍历II；
  - #199 二叉树的右视图；
  - #637 二叉树的层平均值；
  - #429 N叉树的前序遍历；
  - #515 在每个树行中找最大值；
  - #117.填充每个节点的下一个右侧节点指针II
- #226 翻转二叉树
- #104 二叉树的最大深度
- #559 N叉树的最大深度
- #222 完全二叉树的节点个数

##### #144、#94、#145 二叉树的前中后序遍历，递归方法

```cpp {class=line-numbers}
// 前序遍历
void preTra(TreeNode *root, vector<int> &ans)
{
  if (!root)
    return;

  seq.push_back(root->val);
  preTra(root->left, ans);
  preTra(root->right, ans);
}

// 中序遍历
void inTra(TreeNode *root, vector<int> &ans)
{
  if (!root)
    return;

  inTra(root->left, ans);
  ans.push_back(root->val);
  inTra(root->right, ans);
}

// 后序遍历
void posTra(TreeNode *root, vector<int> &ans)
{
  if (!root)
    return;

  posTra(root->left, ans);
  posTra(root->right, ans);
  ans.push_back(root->val);
}

vector<int> treeTraversal(TreeNode *root)
{
  vector<int> ans;
  preTra(root, ans);
  // inTra(root, ans);
  // posTra(root, ans);
  return ans;
}
```

##### #144、#94、#145 二叉树的前中后序遍历，迭代方法

```cpp {class=line-numbers}
// 先序遍历
vector<int> preorderTraversal(TreeNode *root)
{
  vector<int> ans;
  if (!root) return ans;

  stack<TreeNode *> st;
  st.push(root);
  while (!st.empty())
  {
    TreeNode *tmp = st.top();
    st.pop();
    ans.push_back(tmp->val);
    if (tmp->right) st.push(tmp->right);
    if (tmp->left) st.push(tmp->left);
  }

  return ans;
}

// 中序遍历
vector<int> inorderTraversal(TreeNode *root)
{
  vector<int> ans;
  if (!root)
    return ans;

  stack<TreeNode *> st;
  st.push(root);
  TreeNode *tmp = root;
  while (!st.empty())
  {
    while (tmp && tmp->left) // 向左找到最左边的节点
    {
      st.push(tmp->left);
      tmp = tmp->left;
    }

    TreeNode *tmp2 = st.top();
    st.pop();
    ans.push_back(tmp2->val);

    if (!tmp2->right) // 如果当前处理的节点没有右孩子，准备出栈下一个节点
      tmp = nullptr;
    else // 如果当前处理的节点有右孩子，从该右孩子开始找最左边的节点
    {
      st.push(tmp2->right);
      tmp = tmp2->right;
    }
  }
  return ans;
}

// 后序遍历：先序为“根左右”，可稍微调整为“根右左”，再逆序为“左右根”
vector<int> postorderTraversal(TreeNode *root)
{
  vector<int> ans;
  if (!root)
    return ans;

  stack<TreeNode *> st;
  st.push(root);
  while (!st.empty())
  {
    TreeNode *tmp = st.top();
    st.pop();
    ans.push_back(tmp->val);
    if (tmp->left) st.push(tmp->left);
    if (tmp->right) st.push(tmp->right);
  }
  reverse(ans.begin(), ans.end());

  return ans;
}
```

##### #102 二叉树的层序遍历

```cpp {class=line-numbers}
vector<vector<int>> levelOrder(TreeNode *root)
{
  vector<vector<int>> ans;
  if (!root)
    return ans;

  queue<TreeNode *> q;
  q.push(root);
  while (!q.empty())
  {
    int size = q.size();
    vector<int> tmp(size, 0);
    for (int i = 0; i < size; ++i)
    {
      TreeNode *cur = q.front();
      q.pop();
      tmp[i] = cur->val;
      if (cur->left)
        q.push(cur->left);
      if (cur->right)
        q.push(cur->right);
    }
    ans.push_back(tmp);
  }

  return ans;
}
```

##### #226 翻转二叉树

```cpp {class=line-numbers}
TreeNode *invertTree(TreeNode *root)
{
  if (!root)
    return root;

  swap(root->left, root->right);
  invertTree(root->left);
  invertTree(root->right);
  return root;
}
```

##### #226 判断一棵树是否对称

```cpp {class=line-numbers}
// 递归写法
// 判断两棵树是否对称
bool compare(TreeNode *left, TreeNode *right)
{
  if (!left && !right)
    return true;
  if ((!left && right) || (left && !right))
    return false;
  if (left->val != right->val)
    return false;

  bool lflag = compare(left->left, right->right); //左树的左子树应该和右树的右子树对称
  bool rflag = compare(left->right, right->left); //左树的右子树应该和右树的左子树对称
  return lflag && rflag;
}

bool isSymmetric(TreeNode *root)
{
  if (!root)
    return true;
  return compare(root->left, root->right);
}
```

```cpp {class=line-numbers}
// 队列辅助迭代法
bool isSymmetric(TreeNode *root)
{
  if (!root)
    return true;
  //return compare(root->left, root->right);
  queue<TreeNode *> q;
  q.push(root->left);
  q.push(root->right);
  while (!q.empty())
  {
    TreeNode *l = q.front();
    q.pop();
    TreeNode *r = q.front();
    q.pop();

    if (!l && !r)
      continue;
    if ((!l && r) || (l && !r))
      return false;
    if (l->val != r->val)
      return false;

    q.push(l->left);
    q.push(r->right);
    q.push(l->right);
    q.push(r->left);
  }
  return true;
}
```

##### #222 完全二叉树的节点个数

```cpp {class=line-numbers}
// 直接遍历与利用完全二叉树的性质
int countNodes(TreeNode *root)
{
  if (!root) return 0;
  
  // return 1 + countNodes(root->left) + countNodes(root->right);

  TreeNode *l = root->left, *r = root->right;
  int lh = 0, rh = 0;

  while (l) { ++lh; l = l->left; }
  while (r) { ++rh; r = r->right; }
  if (lh == rh) return (2 << lh) - 1;

  return 1 + countNodes(root->left) + countNodes(root->right);
}
```

```cpp {class=line-numbers}

```

### 7. 图

```cpp {class=line-numbers}

```

### 8. 动态规划

```cpp {class=line-numbers}

```

#### #300 最长递增子序列

给你一个整数数组`nums`，找到其中最长严格递增子序列的长度。子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。

```cpp {class=line-numbers}
// 动态规划解法
// 定义dp[i]为考虑前i个元素，以第i个数字结尾的最长上升子序列的长度，注意nums[i]必须被选取。
int lengthOfLIS(vector<int> &nums)
{
  int n = (int)nums.size();
  if (n == 0)
    return 0;

  vector<int> dp(n, 0);
  for (int i = 0; i < n; ++i)
  {
    dp[i] = 1;
    for (int j = 0; j < i; ++j)
    {
      if (nums[j] < nums[i])
        dp[i] = max(dp[i], dp[j] + 1);
    }
  }
  return *max_element(dp.begin(), dp.end());
}
```

```cpp {class=line-numbers}
// 贪心 + 二分查找
int lengthOfLIS(vector<int> &nums)
{
  int len = 1, n = (int)nums.size();
  if (n == 0)
    return 0;

  vector<int> d(n + 1, 0);
  d[len] = nums[0];
  for (int i = 1; i < n; ++i)
  {
    if (nums[i] > d[len])
      d[++len] = nums[i];
    else
    {
      int l = 1, r = len, pos = 0; // 如果找不到说明所有的数都比nums[i]大，此时要更新d[1]，所以这里将pos设为0
      while (l <= r)
      {
        int mid = (l + r) >> 1;
        if (d[mid] < nums[i])
        {
          pos = mid;
          l = mid + 1;
        }
        else
          r = mid - 1;
      }
      d[pos + 1] = nums[i];
    }
  }
  return len;
}
```

### 9. 贪心思想

#### #455 分发饼干

```cpp {class=line-numbers}

```

#### #135 分发糖果

```cpp {class=line-numbers}

```

#### #435 无重叠区间

```cpp {class=line-numbers}

```

#### #452 用最少数量的箭引爆气球

```cpp {class=line-numbers}
int findMinArrowShots(vector<vector<int>> &points)
{
  // 和435题思路相同，可转换为求解最大不重叠区间的个数，不过这里区间端点相同也算重叠
  int n = points.size();
  if (n <= 1)
    return n;

  sort(points.begin(), points.end(), [](vector<int> &a, vector<int> &b) { return a[1] < b[1]; });

  int pre = points[0][1], total = 1;

  for (int i = 1; i < n; ++i)
  {
    if (points[i][0] > pre)
    {
      ++total;
      pre = points[i][1];
    }
  }
  return total;
}
```

#### #605 种花问题

```cpp {class=line-numbers}

```

#### #763 划分字母区间

题目描述：字符串`S`由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。返回一个表示每个字符串片段的长度的列表。

```cpp {class=line-numbers}

```

### 10. 回溯

#### 10.1 引言

#### 10.2 相关题目

##### #77 求组合数

```cpp {class=line-numbers}
void backtracking(vector<vector<int>> &ans, vector<int> path, int n, int k, int count)
{
  if (path.size() == k)
  {
    ans.push_back(path);
    return;
  }

  for (int i = count; (n - i + 1) >= (k - path.size()); ++i)
  {
    path.push_back(i);
    backtracking(ans, path, n, k, i + 1);
    path.pop_back();
  }
}
vector<vector<int>> combine(int n, int k)
{
  vector<vector<int>> ans;
  vector<int> path;
  backtracking(ans, path, n, k, 1);
  return ans;
}
```

##### #46 求全排列

```cpp {class=line-numbers}
void backtracking(vector<vector<int>> &ans, vector<int> &path, 
        vector<int> &nums, vector<bool> &used)
{
  if (path.size() == nums.size())
  {
    ans.push_back(path);
    return;
  }

  for (int i = 0; i < nums.size(); ++i)
  {
    if (!used[i])
    {
      used[i] = true;
      path.push_back(nums[i]);
      backtracking(ans, path, nums, used);
      used[i] = false;
      path.pop_back();
    }
  }
}

vector<vector<int>> permute(vector<int> &nums)
{
  vector<vector<int>> ans;
  vector<int> path;
  vector<bool> used(nums.size(), false);
  backtracking(ans, path, nums, used);
  return ans;
}
```

```cpp {class=line-numbers}

```

```cpp {class=line-numbers}

```

## 《剑指offer》面试题3

### 题目1：数组中的重复元素

数组长度为`n`，数组元素的取值范围为`0 ~ n - 1`，求是否存在重复元素

```cpp {class=line-numbers}
// 交换元素，使元素落在其合适的位置
// 时间：O(n)，空间：O(1)
bool containsDuplicate(vector<int>& nums) 
{
  if (nums.size() < 1)
      return false;
  for (int i = 0; i < nums.size(); ++i)
  {
    if (nums[i] < 0 || nums[i] >= nums.size())
      return false;
  }
  
  for (int i = 0; i < nums.size(); ++i)
  {
    while (nums[i] != i)
    {
      if (nums[i] == nums[nums[i]])
        return true;
      
      int tmp = nums[i];
      nums[i] = nums[nums[i]];
      nums[nums[i]] = tmp;
    }
  }

  return false;
}
```

### 题目2：数组中的重复元素

数组长度为`n+1`，数组元素的取值范围为`1 ~ n`，求其中的一个重复元素

```cpp {class=line-numbers}
// 哈希表辅助，时间：O(n)，空间：O(n)
int getDuplication(vector<int> &nums)
{
  if (nums.size() <= 1)
    return -1;

  unordered_map<int, int> count;

  // 初始化哈希表，key为数组元素的值，value为数组元素在数组中的出现次数，初始为0
  for (int i = 0; i < nums.size(); ++i)
    count[nums[i]] = 0;
  
  // 统计各元素在数组中的出现次数
  for (int i = 0; i < nums.size(); ++i)
    ++count[nums[i]];

  // 返回第一个出现次数大于1的元素
  for (int i = 0; i < nums.size(); ++i)
    if (count[nums[i] > 1])
      return nums[i];

  // 没有重复元素
  return -1;
}
```

```cpp {class=line-numbers}
// 折半查找思想，时间：O(nlogn)，空间：O(1)
```

## 阿里牛客笔试题

1. 小强现在有$n$个物品，每个物品有两种属性$x_i$和$y_i$，他想要从中挑出尽可能多的物品满足以下条件：对于任意两个物品$x_i<x_j$且$y_i<y_j$，或者$x_i>x_j$且$y_i>y_j$

```cpp {class=line-numbers}

const int maxn = 1e5 + 10;

struct node
{
  int x, y;
} goods[maxn];

bool cmp(node a, node b)
{
  if (a.x == b.x)
    return a.y > b.y;
  return a.x < b.x;
}

int lengthOfLIS(vector<int> &nums)
{
  int len = 1, n = (int)nums.size();
  if (n == 0)
  {
    return 0;
  }
  vector<int> d(n + 1, 0);
  d[len] = nums[0];
  for (int i = 1; i < n; ++i)
  {
    if (nums[i] > d[len])
    {
      d[++len] = nums[i];
    }
    else
    {
      int l = 1, r = len, pos = 0;
      while (l <= r)
      {
        int mid = (l + r) >> 1;
        if (d[mid] < nums[i])
        {
          pos = mid;
          l = mid + 1;
        }
        else
        {
          r = mid - 1;
        }
      }
      d[pos + 1] = nums[i];
    }
  }
  //for(int i = 1;i <= len;i++) cout<<d[i]<<" ";cout<<endl;
  return len;
}

void solve()
{
  int n;
  cin >> n;
  for (int i = 0; i < n; i++)
  {
    cin >> goods[i].x;
  }
  for (int i = 0; i < n; i++)
  {
    cin >> goods[i].y;
  }
  sort(goods, goods + n, cmp);
  vector<int> vec;
  for (int i = 0; i < n; i++)
  {
    vec.push_back(goods[i].y);
  }
  //for(int i = 0;i < vec.size();i++) cout<<vec[i]<<" ";cout<<endl;
  cout << lengthOfLIS(vec) << endl;
}


int main()
{
  // std::cout << "Func:main() Start\n";

#ifdef TRAING
  const std::string traingFilePath = "E:\\Job\\Markdown-Note\\Code\\trainData1.txt";
  std::freopen(traingFilePath.c_str(), "r", stdin);
#endif

  int T;
  cin >> T;
  while (T--)
  {
    solve();
  }

  // std::cout << "Func:main() end\n";

  return 0;
}
```

```cpp {class=line-numbers}

```

```cpp {class=line-numbers}

```

## 各大公司的笔试题

### 网易

1. 最短回文串：
小易得到了一个仅包含大小写英文字符的字符串，该字符串可能不是回文串。（“回文串”是一个正读和反读都一样的字符串，比如“level”或者“noon”等等就是回文串，“asds”就不是回文串。）小易可以在字符串尾部加入任意数量的任意字符，使其字符串变成回文串。
现在请你编写一个程序，程序要能计算出小易可以得到的最短回文串。

    ```cpp {class=line-numbers}
    #include <bits/stdc++.h>

    using namespace std;

    // 判断字符串s在范围[start, end]是否回文
    bool check(string &s, int start, int end)
    {
      while (start < end)
      {
        if (s[start] != s[end])
          return false;
        ++start;
        --end;
      }
      return true;
    }

    int main()
    {
      string s;
      cin >> s;

      int i = 0;
      // 求最长回文后缀
      for (i = 0; i < s.size(); ++i)
      {
        if (check(s, i, s.size() - 1))
          break;
      }

      // 剩下的前缀的反转即为需要在字符串尾部添加的最短字符序列
      string minAddStr = s.substr(0, i);
      reverse(minAddStr.begin(), minAddStr.end());
      cout << s + minAddStr << endl;
    }
    ```

2. 拆分最多素数：

- 1不是素数，要求将每个数拆成素数最多的方案，2是最小的素数，使劲拆出2即可。

<!-- ### Other

#### #1 两数之和

```cpp {class=line-numbers}
// 暴力枚举，利用两层for循环来遍历每个元素，并查找满足条件的目标元素。
// 时间复杂度为O(N^2)，空间复杂度为O(1)
vector<int> twoSum_1(vector<int> &nums, int target)
{
  vector<int> ret;
  for (int i = 0; i < nums.size() - 1; ++i)
  {
    for (int j = i + 1; j < nums.size(); ++j)
    {
      if ((nums[i] + nums[j]) == target)
      {
        ret.push_back(i);
        ret.push_back(j);
        return ret;
      }
    }
  }
  return ret;
}

// 增加一个Map记录已经遍历过的数字及其对应的索引值。
// 当遍历一个新数字的时候就去Map里查询target与该数的差值是否已经在前面的数字中出现过。
// 如果出现过，就找到了答案，就不必再往下继续执行了。
vector<int> twoSum_2(vector<int> &nums, int target)
{
  unordered_map<int, int> m;
  vector<int> ret;
  for (int i = 0; i < nums.size(); ++i)
  {
    int t = target - nums[i];
    if (m.count(t))
    {
      ret.push_back(m[t]);
      ret.push_back(i);
      return ret;
    }
    m[nums[i]] = i;
  }
  return ret;
}
```

#### #2 两数相加

```cpp {class=line-numbers}
//先比较两个单向链表的长度，将返回值设为较长的链表
ListNode *addTwoNumbers_1(ListNode *l1, ListNode *l2)
{
  ListNode *p1 = l1, *p2 = l2;

  while (l1 && l2)
  {
    l1 = l1->next;
    l2 = l2->next;
  }

  if (l1)
  {
    l1 = p1;
    l2 = p2;
  }
  else
  {
    l1 = p2;
    l2 = p1;
  }

  ListNode *q1 = l1;
  int flag = 0;

  while (l2)
  {
    int next_val = (l1->val + l2->val + flag) % 10;
    int next_flag = (l1->val + l2->val + flag) / 10;
    l1->val = next_val;
    flag = next_flag;
    p1 = l1;
    p2 = l2;
    l1 = l1->next;
    l2 = l2->next;
  }

  while (l1 && flag)
  {
    int next_flag = (l1->val + flag) / 10;
    int next_val = (l1->val + flag) % 10;
    flag = next_flag;
    l1->val = next_val;
    p1 = l1;
    l1 = l1->next;
  }

  if (flag)
  {
    p1->next = new ListNode;
    p1->next->val = flag;
    p1->next->next = nullptr;
    return q1;
  }

  return q1;
}
```

#### #3 无重复字符的最长字串

```cpp {class=line-numbers}
int Solution::lengthOfLongestSubstring(string s)
{
  const char *str = s.c_str();
  return myLengthOfLongestSubstring(str, s.size());
}

int Solution::myLengthOfLongestSubstring(const char *str, int len)
{
  if (len <= 1)
    return len;

  const char *left = str, *right = str + len / 2;
  int max_left = myLengthOfLongestSubstring(left, len / 2);
  int max_right = myLengthOfLongestSubstring(right, len - len / 2);
  int max_mid = midLengthOfLongestSubstring(str, len);
  if (max_left > max_right)
    return (max_left > max_mid) ? max_left : max_mid;
  else
    return (max_right > max_mid) ? max_right : max_mid;
}

int Solution::midLengthOfLongestSubstring(const char *str, int len)
{
  unordered_map<char, bool> m1, m2;
  for (int i = 0; i < len; ++i)
  {
    m1[str[i]] = false;
    // m2[str[i]] = false;
  }

  bool flag1 = true, flag2 = true;
  int i = len / 2 - 1, j = len / 2;
  int left = 0, right = len - 1;
  while (flag1 || flag2)
  {
    if (flag1)
    {
      if (m1[str[i]])
      {
        flag1 = false;
        left = i + 1;
      }
      else
      {
        m1[str[i]] = true;
        --i;
        if (i == -1)
        {
          left = 0;
          flag1 = false;
        }
      }
    }

    if (flag2)
    {
      if (m1[str[j]])
      {
        flag2 = false;
        right = j - 1;
      }
      else
      {
        m1[str[j]] = true;
        ++j;
        if (j == len)
        {
          right = len - 1;
          flag2 = false;
        }
      }
    }
  }

  return (right - left + 1);
}

```

#### #4 寻找两个正序数组中的中位数

```cpp {class=line-numbers}
//低效率解法，先将数组1插入数组2，再算中位数
double findMedianSortedArrays(vector<int> &nums1, vector<int> &nums2)
{
  int len1 = nums1.size(), len2 = nums2.size();
  int len = len1 + len2;
  if (len == 0)
    return 0;
  if (len1 == 0)
    return (len % 2 == 0) ? (nums2[len / 2] + nums2[len / 2 - 1]) / 2.0 : nums2[len / 2];
  if (len2 == 0)
    return (len % 2 == 0) ? (nums1[len / 2] + nums1[len / 2 - 1]) / 2.0 : nums1[len / 2];

  int insert_index = 0;
  for (int i = 0; i < len2; i++)
  {
    int j = 0;
    for (j = insert_index; j < len1 && nums1[j] < nums2[i]; j++)
    {
    }
    nums1.insert(nums1.begin() + j, nums2[i]);
    len1 = nums1.size();
    insert_index = j + 1;
  }
  return (len % 2 == 0) ? (nums1[len / 2 - 1] + nums1[len / 2]) / 2.0 : nums1[len / 2];
}
```

#### #217 数组中的重复元素

给定一个整数数组，判断是否存在重复元素。如果存在一值在数组中出现至少两次，函数返回`true`。如果数组中每个元素都不相同，则返回`false`。

```cpp {class=line-numbers}
// 哈希表辅助求解
bool containsDuplicate(vector<int>& nums) 
{
  if (nums.size() == 0)
      return false;
  unordered_map<int, int> count;
  
  for (int i = 0; i < nums.size(); i++)
  {
      count[nums[i]] = 0;
  }

  for (int i = 0; i < nums.size(); i++)
  {
      if (count[nums[i]])
        return true;
      ++count[nums[i]];
  }
  return false;
  // return set<int>(nums.begin(), nums.end()).size() != nums.size();
}
```

#### #219 数组中的重复元素

给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引`i`和`j`，使得`nums[i] = nums[j]`，并且`i`和`j`的差的绝对值至多为`k`。

```cpp {class=line-numbers}
bool containsNearbyDuplicate(vector<int>& nums, int k) 
{
  if (nums.size() <= 1)
    return false;
  
  unordered_map<int, int> count;

  for (int i = 0; i < nums.size(); ++i)
    count[nums[i]] = -1;
  
  for (int i = 0; i < nums.size(); ++i)
  {
    if ((count[nums[i]] != -1) && (i - count[nums[i]] <= k))
        return true;
    count[nums[i]] = i;
  }
  return false;
}
```

#### #220 数组与滑动窗口

给你一个整数数组`nums`和两个整数`k`和`t`。请你判断是否存在两个不同下标`i`和`j`，使得`abs(nums[i] - nums[j]) <= t` ，同时又满足`abs(i - j) <= k`。如果存在则返回`true`，不存在返回`false`

```cpp {class=line-numbers}
// 暴力解法，注意整数算术溢出
bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) 
{
  if (nums.size() <= 1 || k < 1)
    return false;

  k = (k <= nums.size() - 1 ? k : nums.size() - 1);
  for (int j = 1; j <= k; ++j)
  {
    for (int i = 0; i <= nums.size() - j - 1; ++i)
    {
        if (fabs((long)nums[i] - (long)nums[i + j]) <= t)
            return true;
    }
  }
  return false;
}
``` -->